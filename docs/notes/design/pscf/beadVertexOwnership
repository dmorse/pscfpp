
Note (July 20, 2025): This describes a proposed implementation for a
discrete bead model that could deal with branched polymers. The model
described here was implemented, but then replaced by a model in which 
the vertices are treated as "phantom" beads that are connected to 
each attached block by a bond of length ds = 1/2.

Model (simple bead-spring model):
---------------------------------

   1) Every vertex bead must be "owned" by exactly one of the attached 
      blocks. An end bead is always owned by the single attached block

   2) The bond attaching a vertex to a block is always of the same type 
      as the attached block.

   3) In a linear chain, by default, every block owns its last bead, and 
      the first block also owns its first bead.

   4) In the parameter file for a linear chain, the user sets the number 
      of beads owned by the block.

What new information is required in implementation:

   1) Which polymer model is being used (thread or bead model) ? 
      [Globally accessible enumeration variable]

   2) Which block and/or propagator contains the vertex bead.
      [Define bool member variables in BlockDescriptor and 
       PropagatorTmpl classes]

Model details / implementation stategy:
---------------------------------------

   1) In class BlockDesriptor, each block has a value for nBead_ (the 
      number of beads that it owns). For a discrete bead model, the
      parameter file should contain values for nBead.  The Rpc::Block 
      and Rpg::Block classes will still also have values for ns_ and ds_. 
      In a thread model, nBead_ = ns_. The member variable nBead is only
      used for the bead model, while member variable length is only used
      for the thread model. This can be enforced by preconditions that
      make it illegal to get or set these variables when using a model
      in which they are meaningless. 

   2) Internally, each propagator stores ns_ slices, indexed 
      0, ..., ns - 1, as in the current thread model.  Slice 0 is always
      associated with the head vertex and field ns - 1 is associated with 
      the tail vertex.  The number ns can vary from nBead to nBead + 2, 
      depending on whether the block owns both, one or none of the two 
      terminating vertex beads. When a block does not own both terminal
      vertices, ns > nBead because the Propgator class will still store 
      a slice associated with each of the terminal vertex beads.

   3) Every vertex bead must be owned by exactly one of the attached
      blocks. An end bead is always owned by the attached block. This
      constraint can be checked when the parameter file is read. It 
      may be satisfied by convention in the case of linear polymers,
      by assigning the vertex between bonds i and i+1 to bond i. 

   4) For all non-vertex beads, propagator slice i associated with bead 
      i always contains the field weight factor exp(-W(i)*ds) associated 
      with bead i, for i = 1, ns - 2. The slice associated with the head
      vertex bead (i=0) also includes a weight factor arising from the
      head vertex bead.  The slice associated with the tail vertex bead 
      (i = ns - 1), however, includes this field weight factor arising
      from itself if and only if the propagator owns the tail vertex 
      bead. If the propagator does not own the tail vertex bead, then 
      the slice associated with the tail is treated as the end of a 
      dangling bond, which is created by applying the bond operator to 
      the previous bead (ns-2), without applying a weight function 
      arising from the tail vertex bead (ns-1).

      This convention for propagator slices associated with tail vertices
      is designed to make it easy to compute initial conditions for head
      vertices by pointwise multiplication, as discussed below.
      
   5) A function Block::stepBead that will be used for steps from
      i-1 to i for i = 1, ..., ns_ - 2 will first apply a bond operator 
      exp(-k^2 b^2 *ds/6) and then apply the field weight operator 
      exp(-W*ds). 

   6) The tail weight for bead ns - 1 (the tail bead) is obtained by 
      applying a bond operator to bead ns - 2, and then applying a 
      field weight in-place if and only if the propagator owns the 
      tail vertex bead. 

   7) The head slice for a head vertex that is not owned by a propagator 
      is given by the pointwise product of tail fields associated with 
      sources, exactly as in the current code. In this case, this product 
      will always include a weight function for the vertex bead that 
      arises from the tail slice for the source propagator that owns the 
      vertex bead. The head slice for a propagator that owns the head 
      vertex bead must, however, instead acquire an additional weight 
      factor for the bead.  This additional weight factor must be 
      applied by the propagator that owns the bead, as part of the 
      computation of the initial value of q for the head. 

   8) Computation of contributions to monomer concentrations from 
      non-vertex beads must include a factor of the inverse of the
      weight factor associated with each bead, as in Matsen's algorithm. 
      This inverse weight factor should be stored separately, in a member
      of Block called expWInv_, because it is applied repeatedly, and 
      because division is 2-3 times more expensive than multiplication.  

   9) The contribution of each vertex bead to overall concentration 
      is only included in summations for the block that owns it. 
      Each such bead has an associated head slice from one propagator 
      and a tail slice from the other associated with the same block,
      and both of these propagators include the field weight factor
      arising from that vertex bead. The contribution to the monomer
      concentration from such a vertex bead thus must include a factor 
      of the inverse of the bead field weight expWInv_ to avoid double
      counting of this factor, exactly as for non-vertex beads. 

Proposed Implementation:
------------------------

  --- Modifications applied in Pscf, which then work in both Rpc and Rpg
 
1) Define an namespace Pscf::PolymerModel that contains an unscoped
   (C-style) enumeration and several functions to set and get a global
   value of this enumeration. Use the global value throughout the code
   to test which model is being used:

namespace Pscf{
namespace PolymerModel{

  enum Type = {Thread, Bead};

  void setModel(PolymerModel::Enum);

  PolymerModel::Enum model();

  bool isThread();
  bool isBead();

  void lock();
  bool isLocked();

}
}

Define extractor and inserter (>> and <<) operators to read and write 
values of the PolymerModel::Type enumeration.

The functions in the namespace all set, query and lock values of a 
pseudo-private enumration variable model_ that is defined and initialized 
in an anonymous namespace in PolymerModel.cpp.

Rules: 

   - The variable polymerModel_ is initialized to PolymerModel::Thread

   - In a PSCF program such as pscf_pc, PolymerModel::setModel should
     only be called once, if at all.  The same model must be used 
     throughout program execution. 

   - Unit tests must, however, have the freedom to switch back and
     forth between models in order to implement tests of both models. 

   - Unit tests that test features of the bead model should reset the
     model to PolymerModel::Thread in the tearDown function.

Note: The lock() function could be called in a main program file after 
the model type is initialized in the readParamaters function, to make it 
immutable thereafter.  The lock function may not be used in uni tests, 
however, since it would apply to all subsequent tests. I'm still trying
to figure out a better way of enforcing immutability in production code
while allowing mutability in unit tests.

Done (in Pscf)

2) Create a member nBead_ in the BlockDescriptor class. 
When PolymerModel::isBead(), have the inserter and extractor operators 
for the BlockDescriptor, read nBead rather than length. For a bead model,
compute ns_ from nBead once it is known which end beads the block owns, 
if any. Allow access to functions that get or set BlockDescriptor::nBead 
only if PolymerModel::isBead(). Similarly, allow access to functions that 
get or set Block::length only if PolymerModel::length. The nBead and 
length properties are each meaningful only within one model, and may
not be used in the other. 

Done (in Pscf)

3) For the BlockDescriptor class, add a private member array Pair<bool> 
ownsVertex_ , a set function void setVertexOwnership(int i, bool) and a 
get function bool ownsVertex(int i). Allow access to functions that get 
or set  only if PolymerModel::isBead(), since these variables are 
meaningless in a thread model. 

Change the text representation of a block for a branched polymer for the 
bead model so as to read values of ownsVertex(0) and ownsVertex(1). 

Note: For linear molecules, values of ownsVertex for each block can be 
set within Polymer::readParameters after optionally reading and setting
the PolymerType but before reading the blocks, by using a standard 
convention in which block i owns the vertex between block i and block 
i+1 and in which any end vertex is owned by the block it terminates.

Done (inPscf)

4) In the PropagatorTmpl class template, define private bool member
variables named ownsHead_ and ownsTail_, and define public accessor 
functions bool ownsHead() and bool ownsTail(). Also define a set
function setVertexOwnwership(ownsHead, ownsTail). These functions may
only be called when PolymerModel::isBead() is true, because they are
only meaningful in this case.

Done (in Pscf)

5) In Pscf::PolymerTmpl::readParameters add code that, if 
PolymerModel::isBead() is true:

   - Set vertex ownership for blocks in a linear polymer (before 
     reading blocks)

   - Set head and tail ownership in associated propagators

   - For each vertex, check that one incoming propagator owns its tail.

   - For each vertex, check that one outgoing propagator owns its head.

All information about which blocks owns which vertices is thus implemented
in the base class function PolymerTmpl::readParameters, and so can be used
in both Rpc and Rpg.

In Pscf::PolymerTmpl, create function nBead() that returns number of
beads for the polymer in the bead model. The member function length() 
may only be called if PolymerModel::isThread(), while nBead() may only
be called if PolymerModel::isThread(). Rationale: Each of these
variables is only meaningful in the context of one model or the other,
and so these properties may only be queried when the appropriate model
is in use. 

Done (in Pscf)

   --- Modifications that must be duplicated in Rpc and Rpg 

6) In Rpc::Mixture::readParameters, if PolymerModel::isBead(), allow 
reading of ds_ only for the thread model, and set ds_ = 1.0 by default
in the bead model.

Done in Rpc and Rpg

7) Add a private member polymerModel_ to the Rpc::System class. 
Optionally read this as the first member of the block, before the 
beginning of the Mixture class.  The parameter file format would 
thus be:

  System{
     polymerModel*  PolymerModel::Enum
     Mixture{ ... }
     Interaction{ ... }
      ...
  }
 
Set Rpc::System::polymerModel_ to PolymerModel::Thread by default.  When 
the value is known (after it is optionally read), set the global variable 
to the same value by calling PolymerModel::setModel

Done in Rpc and Rpg

8) In Rpc::Block::allocate and re-allocate functions, for bead model, 
compute ns from nBead. In the bead model, ns is equal to nBead when 
both vertices are owned by the block, and  larger than nBead when one 
or both vertices are not owned by the block. The value of ds is set to
1.0 for this model, but ds is not actually ever used in the bead model.

Done in Rpc and Rpg

9) Modified private data structures in Rpc::Block:

In Rpc::Block class, use expW_ to store exp(-W(r)) in the case of the
bead model, but use expW_ to store exp(-W(r)ds/2) in the case of a thread 
model. Use expKsq_ to store exp(-b^2 K^2 / 6) for the bead model and 
exp( -b^2 K^2 ds / 6) for the thread models.  

Only allocate arrays expW2_ and expKSq2_ if PolymerModel::isThread().
These are not used by the bead model. 

Add field expWInv_ that stores exp(+W(r)), for use in summations used
to compute monomer concentrations and partition function. This is only
allocated if PolymerModel::isBead().

Modify functions in Block:

     allocate :

       - Conditionally allocate some private member fields.
         expW2_, expKsq2_ and expWInv_ are only used by one model.

       - Modify definition of ns for different models

     setLength :
       - Make PolymerModel::isThread a precondition 

     setupSolver :

       - Create blocks around computations of expW_, expW2_, expWInv_.
         Two of these are only allocated and used in one model. 
       - Use ds = 1.0 for bead model.

     computeKSq :

       - Compute expKsq2 only for the thread model
       - Use ds = 1.0 for bead model.

Done in Rpc and Rpg

10) Block step functions: 

In Rpc::Block class, change the name of the current step function to 
stepThread.  Add three additional public member functions to give:

   void stepThread(RField<D> const & qin, RField<D> & qout) 
   void stepBead(RField<D> const & qin, RField<D> & qout) 
   void stepBondBead(RField<D> const & qin, RField<D> & qout) 
   void stepFieldBead(RField<D> & q)

The function stepFieldBead applies the field weight exp(-W[i]*ds).
Function stepBondBead applies a bond weight by applying an FFT, scaling 
in k space and an inverse FFT.  Note that the stepFieldBead function 
applies the scaling in-place scaling, while other functions have 
distinct input and output field arguments. 

The function stepBead simply calls stepBondBead, then stepFieldBead.

Rationale: Separate functions stepBondBead and stepFieldBead are needed
to correctly treat slices associated with head and tail vertices that
may or may not be owned by the propagator. The function stepBondBead 
is needed by Propagator to compute the weight for a tail bead that is 
not owned. The stepFieldBeadFunction is need as part of the 
computation in computeHeadBead for a head bead that is owned by the 
propagator.

Done in Rpc and Rpg

11) Distinct Propagator computeHead functions for both models:

In the Propagator class change the name of the current computeHead
function to computeHeadThread() and define an additional function
computeHeadBead(). The computeHeadBead function call computeHeadThread 
internally, then applies Block::stepFieldBead if and only if the 
propagator owns the head vertex bead.

Done in Rpc

12) Block averageProduct functions:

In the Rpc::Block class, add two functions that can be used by 
Propagator::computeQ to compute the partition function from the 
product of complementary incoming and outgoing slices at a vertex.

   double averageProduct(RField<D> const& qh, RField<D> const& qt)
   double averageProductBead(RField<D> const& qh, RField<D> const& qt)

Function averageProduct returns the spatial average of qh[i]*qt[i], 
and can be used with the thread model or for the bead model for a
bead that is not owned by the propagator. 

Function averageProductBead computes the spatial average of 
qh[i]*qt[i]*expWInv_[i], and is used in the bead model for a vertex 
bead that is owned by the propagator.

In Propagator::computeQ, call the appropriate choice of one of these 
two functions to compute the molecular partition function.

Done in Rpc and Rpg

13) Propagator::solve function:

In Propagator::solve, use an if-else statement to separate 
MDE solver code for the thread model from corresponding code for
the bead model . Code for the thread model invokes computeHeadThread 
and stepThread. Code for the bead model uses computeHeadBead and 
stepBead, while using stepBondBead for the tail bead if this 
propagator does does not own the tail vertex bead.

Done in Rpc and Rpg

14) Move responsibility for computing all block concentrations to 
subclasses of PolymerTmpl :

In the PolymerTmpl::solve() function, remove code at the end that 
computes all block concentrations by calling Block::computeConcentration 
for all blocks. Leave this computation as the responsibility of the 
Polymer::compute function in each implementation-level subclass 
(r1d, rpc, and rpg). Thus add corresponding code to the end of the 
Polymer::compute function in each implementation of Polymer. 

The code added to the end of R1d::Polymer::compute and 
Rpg::Polymer::compute is essentially identical to the code removed 
from PolymerTmpl::solve, since these classes do not (or not yet)
support the bead model. 

The code in Rpc::Polymer::compute allows for thread and bead models, 
as will corresponding code in Rpg::Polymer::compute when converted 
later.

Rationale: Different implementations of this calculation are needed 
for codes that only support a thread model and those that support 
both thread and bead models. The definitions of prefactors that are 
computed by the Polymer class are different for these models, for
reasons that are discussed below.  Delegating responsibility for 
computation of block concentrations to a Polymer subclass makes it 
easier to distinguish these cases in implementations that support 
both models. 

Done in Rpc

15) Computation of block concentration in Block class:

In Block class, define two public functions:

    computeConcentrationThread(double prefactor)
    computeConcentrationBead(double prefactor)

One or the other of these functions is called with an appropriate value 
for the prefactor within the Rpc::Polymer::compute class.

In the thread model, the prefactor must be phi/(q L), where L is the sum 
of the lengths of all the blocks, while computeConcentrationThread 
computes an integral over s (including factors of ds in contributions
to the sum, and using Simpson's rule) and multiplies it by a prefactor

In the bead model, the prefactor must be phi/(q N), where N is the total 
number of beads owned by all blocks, computeConcentrationBead computes 
a sum over all beads that are owned by the block and multiplies it by 
this prefactor.  The summation in computeConcentrationBead is a simple 
sum over all beads that are owned by the block, including a factor of
exp(W[i]*ds) for each bead to correct for overcounting of bead weight 
factors.

Rationale: We use different conventions for the prefactor for the thread 
and the bead models because the Polymer class that computes the prefactor 
knows the length of each block in the thread model and the number nBead
of beads in each block in the bead model, but does not know a value for 
ds that it could use to convert the number of beads to an equivalent 
length.

Done in Rpc and Rpg

16) Computation of stress in Block and Polymer classes:

In Block class, define two public functions:

    computeStressThread(double prefactor)
    computeStressBead(double prefactor)

One or the other of these functions is called with an appropriate 
value for the prefactor within the Rpc::Polymer::computeStress 
function.  Mixture computeStress calls the Polymer::computeStress 
function and thus requires no modification.

Prefactors for the thread and bead model use the same conventions
as for the calculation of concentration: The prefactor is phi/(q L) 
for the thread model and phi/(q N) for the bead model, where L is 
total length (sum of values of length for all blocks) and N is total 
number of beads (sum of values of nBead for all blocks). 

Done in Rpc and Rpg

17) Calculation of SCFT free energies per monomer in System class:

The free energies that are computed in the System class are 
free energies per monomer reference volume in the thread model and
per bead in the bead model. In the System<D>::computeFreeEnergy
function, in calculation of the free energy of a non-interacting
gas, there is a factor of 1/length or 1/nBead that is used to 
convert a free energy per chain into a free energy per monomer.
This now uses Polymer::length() in the thread model and 
Polymer::nBead() in the bead model, surrounded by an 
if (PolymerModel::isThread) { .... } else { .... }

Done in Rpc and Rpg

18) Calculation of Hamiltonian values in Simulator class:

The Simulator::computeHamiltonian function does the same calculation
of an ideal gas free energy as System::computeFreeEnergy, and the 
length should be treated the same way. Where the total length of a
polymer is needed, use polymer length in the thread model and nBead 
in the bead model. 

Done in Rpc and Rpg

19) In Analyzer classes, the Intramolecular class, and elsewhere, look 
for uses of the Block::length() function. Anywhere this function is 
called, create an if statement if (PolymerModel::isThread) { .... } 
else { .... }, and replace the call to thread() by a call to nBead() 
and then cast the value to double. Throughout, values of block length
are replaced by (double)nBead as needed. 
