/*! \page psfts_algorithm_page  Simulation Algorithms

\ref psfts_psa_page    (Prev) &nbsp; &nbsp; &nbsp; &nbsp;
\ref psfts_param_page  (Next) &nbsp; &nbsp; &nbsp; &nbsp;
<BR>

This page discusses several types of algorithm that are used to perform and
analyze PS-FTS calculations , but that are not needed for SCFT calculations.
A discussion of the file format for parts of the parameter file that 
specify choices for these algorithms and associated parameters is given 
on the \ref psfts_param_page "following page" of 

The pscf_pc and pscf_pg programs allow PS-FTS simulations to be performed 
using either Brownian dynamics (BD) or Monte Carlo (MC) algorithms to 
stochastically sample a fluctuating field or fields.  BD and MC sampling 
algorithms for PS-FTS have a similar structure.  A single BD step or MC 
move generally requires generation of a random change in one or more 
exchange fields, followed by use of an iterative algorithm to identify
a new partial-saddle point configuration. Throughout the PSCF 
documentation and source code, iterative algorithms that are used to 
identify partial saddle-point configurations, and thus satisfy the 
menan-field incompressibility constraint, are referred to as "compressor" 
algorithms.

For example, consider a PS-FTS simulation of a standard AB system 
with two monomer types. Such a system has a real exchange field 
\f$ W_{-}({\bf r}) = \omega_{-}({\bf r}) \f$ that undergoes random 
fluctuations and a real pressure-like field 
\f$ W_{+}({\bf r}) = i \omega_{+}({\bf r})\f$ that must be chosen to 
satisfy the partial saddle-point condition. At the beginning of either a 
BD step or MC move for such as system, a small random change is added to 
the exchange field \f$ W_{-} \f$.  Next, an iterative compressor algorithm 
is used to adjust the presssure-like field \f$ W_{+}({\bf r}) \f$ so as 
to satisfy the partial saddle-point condition, thus imposing 
incompressibility at a mean-field level.  Finally, for an MC simulation, 
a decision is made about whether to accept or reject the resulting MC 
move, based on the value of the Hamiltonian in the new partial 
saddle-point configuration.

PSCF also provides tools for data analysis. Users may use the parameter 
file to choose from among a set classes that can periodically compute 
specific physical quantitites, output data to a file, and/or perform 
statistical analyses during a simulation to compute time averages and 
other statistical properties.  

The parameter file for a typical PS-FTS calculation will thus normally
contain a choice of algorithms for the following three purposes:

   - **Sampling** :  A BD step algorithm or a set of MC step algorithms
     that is used to update the fluctuating field components.

   - **Compressor** :  A compressor algorithm that is used to adjust
     the pressure-like field \f$ W_{+} \f$ so as to always satisfy the 
     partial saddle-point condition.

   - **Analyzers** :  File IO and/or data analysis operations that 
     are performed at regular intervals during a simulation.

In addition to these basic building blocks, users may also enable two
other types of optional elements:

   - **Ramp** : A Ramp is a optional feature that allows a user to
     perform a simulation in which one or more model parameters are
     varied continuously over the course of a simulation.

   - **Perturbation** : A Perturbation is an optional feature that
     allows the user to modify the form of the field theoretic
     Hamiltonian by adding a perturbation to the standard form

All of these features are discussed separately below.

In the source code of PSCF, different algorithms of the same type are 
generally implemented by C++ classes that are subclasses of a common 
base class. The generic names that we use in this documentation to 
describe different types of algorithm usuall correspond to the names 
of the corresponding base classes. For example, each Brownian dynamics 
step algorithms is implemented by a subclasses of a base class named 
BdStep, while Monte Carlo moves are implemented by subclasses of base 
class named McMove. Classes that perform file IO and data analysis
operations are subclasses of a class named Analyzer. Classes that
perform parameter ramps or define perturbations are subclasses of 
base classes named Ramp and Perturbation.

The PSCF parameter file format uses selectable parameter file blocks
to allow a user to choose one from a set of different algorithms of 
the same type (as is appropriate for BdStep an Compressor algorithms) 
or to user to choose one or algorithms from among a list of available 
algorithms of the same type (as is appropriate for McMove and Analyzer 
algorithms).

\section psfts_algorithm_BD_sec Brownian Dynamics (BD) Step Algorithms

A Brownian dynamics (BD) algorithm for a particle based simulation is
usually based on discretization of a stochastic differential equation
that generates diffusive dynamics. In the context of a field theoretic
simulation, however, there is no natural way to define dynamics or units
of time, since the BD algorithm is simply being used as a way to sample
an equilibrium distribution. The description of BD step algorithms 
used to define parameters in PSCF based on units in which the fictitious 
"time" is thus measured in units of BD steps, while energy is measured 
in thermal units, in which \f$ kT = 1 \f$.  The magnitude of changes in 
the exchange field(s) per time step is controlled by a parameter that 
is denoted by the label "mobility" in the parameter file, and denoted 
by the symbol \f$ \gamma \f$ in these notes.

As an example, consider the explicit Euler BD step algorithm for a 
standard AB system. This algorithm yields a change 
\f$ \Delta W_{-}({\bf r}) \f$ per time step in the exchange field 
\f$ W_{-}({\bf r}) \f$ at grid point \f$ {\bf r} \f$ that is given by
\f[
  \Delta W_{-}({\bf r}) =
  - \gamma \frac{\delta H}{\delta W_{-}({\bf r})}
  + g({\bf r})
\f]
where \f$ \gamma \f$ is the BD mobility parameter, \f$ g({\bf r}) \f$ is 
a random field displacement, and
\f[
  \frac{\delta H}{\delta W_{-}({\bf r})}
  = \frac{1}{v} \left [
    \frac{2 W_{-}({\bf r})}{\chi_{b}}
    - \Phi_{-}({\bf r}) \right ]
    \quad.
\f]
The random displacement \f$ g({\bf r}) \f$ is chosen independently at 
each node of the computational mesh and each BD step from a Gaussian 
distribution with a vanishing mean value, \f$ \overline{g({\bf r})} = 0\f$, 
and with a variance
\f[
  \overline{g^{2}({\bf r})} = \gamma \Delta V \quad.
\f]
Here, \f$ \Delta V \f$ is the volume per node (or grid point) of the 
computational mesh, given by \f$ \Delta V = V/G \f$, where \f$ V \f$ is 
the total system volume and \f$ G \f$ is the total number of nodes in the 
mesh.  Other authors have sometimes referred to what we call a "mobility" 
as a time step, sometimes indicated by a symbol such \f$ \Delta t \f$ or
\f$ \delta t \f$.

The mobility parameter has an analogous meaning in more sophisticated
BD step algorithms. It always appears as a prefactor of the "force"
(or functional derivative) \f$ \delta H/\delta W_{-}({\bf r}) \f$ in 
expressions for changes in \f$ W_{-}({\bf r}) \f$ over a single time
step.

PSCF currently allows users to choose from among three BD step 
algorithms, which are labelled below by the names of the C++ classes
that implement them:
<ul>
  <li> \ref rpc_LMBdStep_page "LMBdStep" : A "Leimkuhler-Matthews" (LM) 
  BD step algorithm </li>
  <li> \ref rpc_PredCorrBdStep_page "PredCorrBdStep": A predictor 
  corrector algorithm,
  </li>
  <li> 
  \ref rpc_ExplicitBdStep_page "ExplicitBdStep" : An explicit
  Euler algorithm like that described above,  </li>
</ul>
More details about each of these algorithms can be obtained by clicking
on the associated link.

We recommend the Leimkuhler-Matthews (LM) algorithm for general use 
in all BD simulations.  The LM step algorithm is found to provide much
more accurate results than the competing predictor-corrector algorithm, 
allowing the use of larger time steps.  The explicit Euler algorithm is 
signficantly less accurate than the other two alternatives.

\section psfts_algorithm_MC Monte Carlo (MC) Move Algorithms

The PSCF implementation of MC sampling allows the user to specify a set 
of Monte Carlo move types to be used during an MC simulation. When more
than one type of move is specified, one of the move types is chosen at 
random at the beginning of each step, using probabilities that are
specified by the user.  The algorithm for each attempted step of a MC 
simulation is thus as follows:

   - Choose a type of MC move at random from among a set of choices
     specified by the user.

   - Use the chosen MC move to generate a random change in \f$ W_{-} \f$.

   - Use the chosen compressor algorithm to adjust the real pressure-like 
     field \f$ W_{+}({\bf r}) \f$ so as to satisfy the partial 
     saddle-point condition.

   - Evaluate the Hamiltonian in the new partial saddle point state.

   - Use a Metropolis criterion that is designed to satisfy detailed 
     balance to decide whether to accept or reject the move.

   - If the move is rejected, restore the system to the field 
     configuration that had existed before the beginning of the 
     attempted move.

The block of the parameter file for an MC simulation that contains 
information about MC moves, which is labelled "McMoveManager", contains 
one or more subblocks that are associated with different types of move.  
The parameter file block associated with each such MC move type always
contains a "probability" parameter that specifies the probability of 
that type of move being chosen at the start of each step.

PSCF currently only provides the following two MC step algorithms: 
<ul>
  <li> \ref rpc_ForceBiasMove_page "ForceBiasMove": A "smart MC" or
  "force bias" MC move that uses an explicit Euler BD step to 
  generate a proposed MC move. </li>
  <li> \ref rpc_RealMove_page "RealMcMove" : A simple MC move that 
  generates spatially uncorrelated random changes of 
  \f$ W_{-} \f$ at different grid points </li> 
</ul>
The ForceBiasMove algorithm generally leads to much more efficient 
sampling than the simpler real move, and is recommended as the 
workhorse method for MC simulations.

Acceptance rates for MC moves generally decrease rapidly with 
increasing system size. This effect is particularly severe with the 
simple real-space MC move, but also occurs for the force bias move.
Because BD simulation does not suffer from a similar problem, this 
phenomena causes MC to always become less efficient than BD for 
sufficiently large systems. We thus generally recommend the use of BD 
rather than MC simulation for 3D systems with roughly \f$ 10^{4} \f$ 
or more grid points. 

One virtue of MC simulations over BD simulations is that, because MC 
algorithms are designed to satisfy a detailed balance condition, they 
do not exhibit any systematic sampling error. An infinitely long MC 
simulation should, in principle, yield exact results for any average 
value obtained from a particular model on a specified computational
mesh. The only sampling errors in MC simulations are true statistical 
errors arising from the finite length of a simulation, which can be 
estimated by standard methods, and errors arising from round off of 
floating point numbers, which are usually negligible.  BD simulations
instead exhibit an systematic error due to discretization of the time 
coordinate in the Langevin equation, an error that increases with 
increases in the mobility parameter. Results of MC simulations of 
small systems can thus be useful for comparison when evaluating 
correctness of new MC and BD algorithms, and when evaluating systematic 
errors in BD algorithms.

\section psfts_algorithm_compressor_sec Compressor Algorithms

The PSCF paramater file format allows the user to choose from among
several "compressor" algorithms. As discussed above, a compressor is 
an iterative algorithms that adjust the \f$ W_{+} \f$ field so as to 
satisfy a partial saddle-point condition. This algorithm must applied 
at last once per BD or MC stochastic step after each change in 
\f$ W_{-} \f$. Users may choose a compressor algorithm independently 
of their choice for a BD step or MC move algorithms: Any compressor 
algorithm may be used in the context of any BD or MC step algorithm. 

Solution of the saddle-point condition normally requires multiple
iterations of \f$ W_{+} \f$. Each iteration normally involves a 
proposed adjustment of \f$ W_{+} \f$ followed by solution of the 
modified diffusion equation (MDE) in the resulting state, which 
is necessary to evaluate the remaining error. Because repeated
solution of the MDE is the most expensive operation in a FTS, and
the compressor algorithm requires multiple solutions of the MDE 
for each BD or MC step, almost all of the computational time of
PS-FTS calculation is spent within the compressor algorithm. 

The available compressor algorithms are listed below. Users may 
click on the link associated with each algorithm label to access 
more a detailed description of each the algorithm, and of the format 
of the associated parameter file block. 
<ul>
  <li> \ref rpc_LrAmCompressor_page "LrAmCompressor": 
        A linear-response Anderson mixing algorithm </li>
  <li> \ref rpc_LrCompressor_page "LrCompressor": 
        A simple linear-response algorithm </li>
  <li> \ref rpc_AmCompressor_page "AmCompressor":
        An Anderson-mixing algorithm </li>
</ul>
The LrAmCompressor is the default choice, and is recommended for general 
use.  The AmCompressor algorithm is similar to the Anderson mixing 
algorithm used in most previously published PS-FTS calculations. 
The LrAmCompressor and LrCompressor algorithms both use the analytically 
calculated linear response of a hypothetical homogeneous state as an 
approximation to the actual linear response of the monomer concentration 
in an inhomgeneous state to small changes in the pressure-like field 
(i.e., for the Jacobian of the relevant system of equations). 

\section psfts_analyzer_BD_sec Analyzer Algorithms

PSCF provides an extensible set of C++ classes for analysis of field
theoretic simulations, which we refer to generically as analyzers or
analyzer classes.  Each analyzer class performs a specified analysis 
and/or file IO operation at some regular interval during a simulation 
(e.g., every 10 or 100 simulation steps). Analyzer classes can be
designed to periodically compute physical quantities of interest, 
output data to file, or compute statistical properties such as averages
and variances, or any combination of these types of operation. The
PSCF parameter file allows the user to enables a set of zero or more 
analyzers in order to specify which such operations should be performed
during a simulation that is run with the SIMULATE command, and how often 
each should be performed. The same set of analyzer classes may also be 
used during a postprocessing operation that is performed by the ANALYZE 
command, as discussed in more detail \ref psfts_analysis_page "here".

All of the analyzer classes that are provided with the current version 
of PSCF (v1.2) are listed below.  A brief description of the purpose of 
each class is provided below, and further details can be obtained by 
clicking on the class name: The first few classes listed here simply write 
available information to a file or standard output (e.g., the screen) at 
regular intervals, rather than doing any nontrivial data analysis.  
<ul>
  <li> \subpage rpc_StepLogger_page "StepLogger": Record progress of a
        simulation by periodically writing the number of completed BD 
        or MC steps to standard output (e.g., the screen).  </li>
  <li> \subpage rpc_TrajectoryWriter_page "TrajectoryWriter" : Periodically
       write the current configuration of monomer chemical potential fields
       (w-fields) to field trajectory file in r-grid format, for later 
       postprocessing. </li>
  <li> \subpage rpc_ConcentrationWriter_page "ConcentrationWriter" : 
       Periodically write all monomer concentration fields (c-fields) to 
       a file, in r-grid format.
     </li>
  <li> \subpage rpc_HamiltonianAnalyzer_page "HamiltonianAnalyzer" :
       Compute average value of the field theoretic Hamiltonian, and 
       optionally output Hamiltonian values. </li>
  <li> \subpage rpc_BinaryStructureFactorGrid_page "BinaryStructureFactorGrid":
       Compute the structure factor of a system with two monomer types. </li>
  <li> \subpage rpc_MaxOrderParameter_page "MaxOrderParameter" :
       Compute an order parameter that is useful for identifying spontaneous 
       phase transitions. </li>
  <li> \subpage rpc_FourthOrderParameter_page "FourthOrderParameter": 
       Compute another order parameter that is useful for identifying 
       spontaneous phase transitions. </li>
  <li> \subpage rpc_ChiDerivative_page "ChiDerivative": 
       Compute the derivative of free energy with respect to changes in a 
       chi parameter, for use in 
       \ref psfts_algorithm_thermoint_sec "thermodynamic integration".  </li>
  <li> \subpage rpc_ConcentrationDerivative_page "ConcentrationDerivative" 
       Compute the derivative of free energy with respect to changes in 
       total monomer concentation (the inverse of vMonomer), for use in 
       \ref psfts_algorithm_thermoint_sec "thermodynamic integration".  </li>
  <li> \subpage rpc_PerturbationDerivative_page "PerturbationDerivative":
       Compute the derivative of free energy with respect to the strength 
       of a perturbation (the lambda parameter), for use in
       \ref psfts_algorithm_thermoint_sec "thermodynamic integration".  </li>
</ul>

Note that several of the analyzers listed above are designed specifically 
for use in thermodynamic integration calculations. 

\section psfts_algorithm_thermoint_sec Thermodynamic Integration

Thermodynamic integration is a technique for computing a difference in 
values of the free energy in states characterized by different values of 
a model parameter. This free energy difference is computed by numerically 
integrating the derivative of the free energy \f$ F \f$ with respect model 
parameter. Suppose \f$ \lambda \f$ is a parameter that appears in the 
field theoretic Hamiltonian \f$ H \f$. The method is based on a theorem
which states that the derivative fo the free energy \f$ F \f$ is given
by an average value
\f[
   \frac{\partial F}{\partial \lambda}
   = \left \langle \frac{\partial H}{\partial \lambda} \right \rangle
  \quad,
\f]
where \f$ \partial H/\partial \lambda \f$ is a derivative evaluated 
with fields held fixed, and \f$ \langle \cdots \rangle \f$ denotes an 
equilibrium ensemble average evaluated using a specified value of 
\f$ \lambda \f$. 

The change in \f$ F \f$ associated with a change in \f$ \lambda \f$ 
from \f$ \lambda_{0} \f$ to \f$ \lambda_{1} \f$ is obtained by 
integrating the derivative \f$ \partial F/ \partial \lambda \f$ over 
this range. The integral can be computed by either of two methods:

  - **Separate simulations** : Equilibrium simulations can be performed 
    at a set of values of \f$ \lambda \f$ within the range of interest, 
    each of which yields a value of \f$ \partial F/\partial \lambda \f$ 
    at a single value as an ensemble average. The required integral is 
    then approximately computed by numerical integration of the resulting 
    values. 

  - **Continuous integration** : The integral may be computed by using a
    \ref psfts_algorithm_ramp_sec "ramp" to continuously vary the parameter 
    of interest over the course of a simulation. 

Continuous integration may be used either to compute the change in free
energy associated with a change in a parameter of the standard field
theoretic Hamiltonian (such as an interaction parameters or monomer 
concentration) or a change in free energy associated with a 
\ref psfts_algorithm_perturbation_sec "perturbation" that modifies the 
form of the Hamiltonian (as done in Einstein crystal integration).

\section psfts_algorithm_ramp_sec Parameter Ramp

A "ramp" is an optional feature for FTS that allows a user to continuously
vary one or more model parameters during a simulation.  The main uses for 
parameter ramps are:

  - Inducing a spontaneous phase transformation during a slow parameter 
    ramp to identify the approximate location of an equilibrium phase 
    boundary (e.g., an order-disorder transition).

  - Evaluating the integral of some ensemble average with respect to 
    changes in a model parameter in order to implement continuous 
    thermodynamic integration.

The only ramp algorithm provided by the current version of PSCF is a
implemented by the LinearRamp class. This is algorithm allow the users to 
perform a ramp in which any set of of the standard physical parameters 
vary linearly with the BD or MC step counter.  The interface for a 
LinearRamp is closely analogous to that of the LinearSweep class used 
for SCFT sweep calculations, as discussed on a \ref psfts_ramp_page 
"separate manual page". 


\section psfts_algorithm_perturbation_sec Perturbation

A "perturbation" is an optional feature that allows the user to modify 
the form of the field theoretic Hamiltonian by adding an arbitrary
additional functional of the w-fields to the standard Hamiltonian.

The only type of perturbation is currently available is implemented
by the EinsteinCrystalPerturbation class. This class is designed to 
enable the Einstein crystal method of computing absolute free 
energies. The interface for EinsteinCrystalPerturbation is discussed 
in detail on a \ref psfts_perturb_page "separate manual page". 


<BR>
\ref psfts_psa_page    (Prev) &nbsp; &nbsp; &nbsp; &nbsp;
\ref psfts_page        (Up) &nbsp; &nbsp; &nbsp; &nbsp;
\ref psfts_param_page  (Next) &nbsp; &nbsp; &nbsp; &nbsp;

*/
