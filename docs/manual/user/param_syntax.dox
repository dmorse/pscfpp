/*! \page user_param_syntax_page 3.3.2 Parameter File Syntax

\ref user_param_example_page (Prev) &nbsp; &nbsp; &nbsp; &nbsp; 
\ref user_param_mixture_page (Next) 
<BR>

This page gives a more complete discussion of syntactical conventions
used in all PSCF parameter files. The discussion expands on some aspects 
introduced in the discussion of the example shown on the previous page, 
and introduces some aspects that were not discussed there.

PSCF parameter files are fixed format files, in which each element can
only appear at a specific location within the file. Some flexibility
can be introduced, however, by allowing some elements to be optional or 
polymorphic, as discussed greater detail below.  The format requires
that the user provide a label at the beginning of each element that 
identifies the element, and that can be checked against an expected
label or a set of possible allowed values. This allows the code that
reads a parameter file to confirm its validity while it is being read,
and to provide informative error messages when an error is found.

\section user_param_syntax_blocks_section Parameter File Blocks

Every PSCF parameter file consists of a heirarchy of of nested parameter 
blocks that are delimited by opening and closing curly braces.  Each such 
block begins with a capitalized label for the block followed immediately 
by an opening curly bracket on the same line.  Each block ends with a 
closing bracket on a line by itself, as in 
\code
  BlockName{
     ....
  }
\endcode
Note that there may not be any whitespace space between the block 
label (e.g., "BlockName", or "Mixture") and the opening curly bracket.

Each such parameter block may contain a sequence of the following 
types of elements:
<ul>
   <li> 
     Nested Subblocks: Each nested subblock is delimited by a label
     and matched opening and closing curly brackets, as described
     above. 
   </li>
   <li> 
     Individual Parameters:
     Each individual parameter value appears on a single line that 
     contains a parameter label followed by a text representation 
     of the parameter value. Examples in the above parameter file 
     include the integer nMonomer parameter in the Mixture block, 
     and the nBlock and phi parameters within each Polymer subblock
     of the Mixture block. 
   </li>
   <li> 
     1D Arrays of Parameters: Each such array begins with a parameter 
     label that ends with a left square bracket ("[") and ends with line 
     containing a matching right square bracket ("]"). Between these 
     delimiters are lines containing values of array elements, with 
     one value per line, listed in the order of increasing array 
     element index. 
   </li>
   <li> 
     2D Arrays of Parameters:  Each 2D array or matrix of parameters 
     begins with a label and an opening delimiter, and ends with a 
     corresponding closing delimiter.  An example is the chi( .... ) 
     array of the ChiInteraction block, which uses a syntax in which
     the list of elements is delimited by opening and closing 
     parentheses.
   </li>
</ul>
Each block within a parameter file has a fixed file format: The order 
in which elements may appear within each block of a parameter file is 
predefined by the code that reads the block. 

The code that reads a block of a parameter field checks the syntax of
the file format by checking that the label that begins each subblock
and parameter matches an expected value.  If the label does not match
the expected label for a required element, the program will halt 
execution after writing an error message explaining what label it 
expected and what it actually found. When combined with echoing of 
the parameter file (by using "-e" command line option) these error 
messages make it relatively easy for users identify and correct most 
parameter file syntax errors.

The name of each block within a parameter file generally corresponds to 
the name of a class or class template in the underlying C++ code.  The 
data contained within such a block generally contains the information 
required to initialize the internal state of an instance of the specified 
class. The code required to read the parameter file block associated for 
a particular class is almost always defined in a member function of that 
class named "readParameters". Users who are comfortable with C++ can thus 
use knowledge of this convention to easily find the source code that reads 
a particular parameter file block.

Nesting of blocks within a parameter file generally reflects parent-child 
ownership relationships among objects in the corresponding C++ code: 
Each subblock generally corresponds to an object that the parent object 
"owns", i.e., an object that is either a member of the parent object or 
a dynamically created object that the parent object is responsible for 
creating and destroying.  The outermost block in the each parameter file
a "System" block. This reflects the fact that main object in each PSCF
program is an instance of a class named System.

\section user_param_syntax_parameter_section Individual Parameters

Each entry that assigns a value to an an individual parameter is given
on a single line that contains a label string that identifies the name 
of the parameter, followed by one or more spaces, and then a text 
representation of the parameter value.
For example, the entry associated with the nMonomer integer parameter 
within the Mixture block of a system that contains two distinct types 
of monomer (nMonomer == 2) would look like
\code
   nMonomer      2
\endcode
The label for each parameter generally corresponds to a slightly 
modified version of the name of a member variable of the relevant 
parent class, i.e., a member variable of the class whose name is 
specfied in the first line of the innermost enclosing parameter 
file block.  

Values of individual parameters are always read from an input stream 
using the C++ ">>" operator. The value of any parameter that is stored 
in a variable of a primitive C data types (e.g., an integer or floating 
point number) or a string may thus be given using a standard C text 
representation for that data type.

Values of some parameters are stored as instances of non-primitive 
data types, such as classes or enumerations, that are defined within 
the PSCF source code.  Values for such variables are also read from 
file using the ">>" operator.  In these cases, the text representation 
of the "value" of each such non-primitive variable must be defined by 
an overloaded iostream extractor (>>) and insertor (<<) operators that 
are defined for that data type. 

For example, in the example, the "type" parameter within each Polymer 
subblock of the Mixture block is stored as an enumeration with two 
possible values, for which the text representations are the strings 
"linear" or "branched". The value of the "type" parameter must thus be
given in the parameter file by a string with one of these two allowed 
values. 

\section user_param_syntax_array_section 1D Arrays of Parameters 

Values of some parameters are stored as elements of a one-dimensional 
array.  Each such array is formatted in a multi-line format in which 
the first row contains a label that contains the name of the array 
followed immediately by an opening square bracket, and the last line 
contains a matching closing square bracket on a line by itself. 
Between these delimiters are values of elements of the array, with 
one element per line.  The parameter file entry for the contents of
an array named A with N elements is thus of the form
\code
     A[
        A[0]
        A[1]
         :
        A[N-1]
     ]
\endcode
where A[0], ... A[N-1] denote values for the elements, with zero-based
indices.  In the example given in the previous page, this syntax is used 
for the "monomers" array within the Mixture block, and the "blocks" 
arrays within each Polymer subblock of the Mixture block.  

The number of expected elements of such an array must generally be 
specified by the value of a parameter that appears before the array 
in the parameter file. For example, the number of monomer types is 
specified by parameter nMonomer that appears just before the 
"monomers" array. 

\section user_param_syntax_matrix_section 2D Arrays of Parameters 

Variables that are stored internally in two-dimensional arrays can 
use one of two different multi-line parameter file formats. We will
refer to these in what follows as "element format" and "row format".
In either format, dimensions of 2D arrays must be provided by 
parameters that appear in the parameter file before the array. 

<b> Element Format: </b>
In element format, the value of each nonzero element appears on separate
line. This is the format used in above example for the chi matrix.
The element format for an array starts with a line that contains a 
name label followed immediately by an opening parenthesis, and ends 
with a line containing a closing parenthesis. Between these are lines 
that each contain a row index, column index and value of a single
element. When used for square symmetric matrices, like the chi matrix,
this format requires that one enter either the (i,j) or (j,i) element
but not both. The same value is then assigned to both of these 
equivalent elements when either is encountered in the parameter file. 
In this format, elements that are not assigned values are set to zero 
by default, and distinct nonzero elements can appear in any order.

For example, values for elements of a symmetric matrix of chi 
parameters in a system of 3 monomers (nmonomer = 3) with nonzero 
off-diagonal elements and vanishing diagonal elements might look 
something like this
\code
   chi(
       2   0   30.0
       0   1   10.9
       1   2   34.0
   )
\endcode
In this example, zero values are assigned to all diagonal elements
by default.  Nonzero values could be assigned to diagonal elements
by including them in the parameter file format.

<b> Row Format: </b>
In row format, each line of parameter values contains the values for
all of the elements of one row of a corresponding matrix. The row
format for a 2D array begins with a line that contains a label string
followed immediately by an opening square bracket, and ends with a
line containing a closing square bracket on a line by itself, exactly
as for a 1D array. Between these opening and closing lines are lines 
that each contain one row of the corresponding matrix, with values 
of elements formatted exactly as in the standard representation of 
a matrix as an array of number as used in matrix linear algebra. 

For example, the row format for elements of 2 x 3 matrix named 
"matrix" would use a format something like this:
\code
   matrix[
       -15.3   23.0   1.9
         4.8   -9.7  23.3
   ]
\endcode

\section user_param_syntax_optional_section Optional Elements

Each labelled element in a parameter file (i.e, each block or parameter) 
may be either required or optional. Most elements required. 

The label associated with a required element must appear at the expected 
position in a file format, or the program will halt after writing a
error message to standard output that explains the nature of the error. 

The entry for an optional block or parameter may be either included or 
omitted.  If the label associated with an optional block or parameter is 
not found at the expected location in a parameter file, the program will
continue on and try to instead match the label that was found at that
local with the label that identifies the next expected element.
Optional parameters that are omitted from a parameter file are assigned 
default values. 

When echoing of a parameter file is enabled, by invoking a program with
the -e option, the name of each omitted optional parameters is echoed to
standard output followed by the string "[absent]" to indicate that it
was omitted.

Some parameters or blocks in a parameter file may also be required or 
allowed only if parameters that have been read previously take on 
specific values.  Generally, the PSCF parameter file format does not 
require or allow entry of parameters that are known to be meaningless 
or irrelevent on the basis of parameter values that appear earlier in 
the parameter file.

\section user_param_syntax_polymorphic_section Polymorphic Blocks

Some blocks in a PSCF parameter file are "polymorphic".  A polymorphic 
block is one that may contain the initial label and format appropriate 
to any of several possible classes that are subclasses of a particular 
base class, and that that serve analogous purposes. In a polymorphic 
parameter file block, the name of the desired subclass is identified 
by the class name label that appears in the opening line of the block. 
The use of polymorphic blocks allows a user to choose at run time from 
among several possible alternative algorithms or other elements of a 
computation.

For example, the block that represents an iterator in a SCFT calculation 
is usually a polymorphic block. The use of a polymorphic block for 
iterators allows users to specify a choice from among several different 
available iterator algorithms. In the above example, the NRIterator 
block appears at a location at the program expects to find the name 
of one of several possible subclasses of the Fd1d::Iterator base class, 
which implement different iterator algorithms. The appearance of a block 
that begins with the name "NRIterator" tells the program that the user 
has selected a Newton-Raphsom iterator that is implemented by the class 
Fd1d::NRIterator, which is a subclass of Fd1d::Iterator. Different 
subclasses of Fd1d::Iterator implement different iteration algorithms,
and generally require different input parameters, define different 
parameter file block formats.
 
<BR>
\ref user_param_example_page  (Prev) &nbsp; &nbsp; &nbsp; &nbsp; 
\ref user_param_page          (Up) &nbsp; &nbsp; &nbsp; &nbsp; 
\ref user_param_mixture_page  (Next) 

*/
