/*! \page developer_build_dependency_page Dependency Files

\ref developer_build_list_page   (Prev) &nbsp; &nbsp; &nbsp; &nbsp;
\ref developer_build_config_page (Next)
<BR>

The pattern rules used by PSCF to create an object file target by 
compiling a source file with file extension .cpp or .cu create both
an object file with file extension .o and a corresponding dependency 
file with file extension *.d.  The resulting dependency file defines 
a makefile rule that lists all of the prerequisites of the corresponding 
object file, but that has no associated recipe.  The dependency file 
associated with an object file named Class.o defines a makefile rule 
that, is simplified form, might look something like this:
\code

Class.o: Class.cpp Class.h Header1.h Header2.h ....

\endcode
The rule defined in a dependency file does not contain a recipe because 
the make utility can infer the required recipe from a related pattern 
rules that species how to create any *.o object file from a source file
with file name extension *.cpp or *.cu.  The list of prerequisites for 
each object (*.o) file target includes the corresponding source file 
(with extension .cpp or .cu) and all of the header files (extension .h) 
that this source file directly or indirectly includes via  C/C++ 
preprocessor \#include directives. 

The list of prerequisites given in a dependency file is generated 
automatically by using a compiler option to analyze C++ include 
directives. The list of prerequisites generated by the PSCF build 
system also generally includes one or more config.mk configuration 
files that define makefile variables whose values can affect conditional 
compilation of some features.  Though not shown in the above example, 
the paths to the target and its prerequisites given in the rule defined 
in a dependency file are all given as absolute paths, defined relative 
to the root of the entire filesystem.

Because dependency files are created as a side effect of compilation,
the dependency file associated with a compilable source file does not 
exist before the first time that source file compiled. In this case, 
however, the object file target is always considered outdated (since 
non-existent files are always outdated) and so the target will always 
be built if the rule to construct the object file target is invoked. 
The list of prerequisistes of an object target file is thus only used 
after the target is first created, to determine if an *existing* target 
file is outdated and thus needs to be rebuilt if the corresponding rule
is invoked. 

Makefiles that are located in subdirectories of the PSCF src or bld
directories all contain expressions that include multiple dependency 
files via include directives of the form
\code

-include $([directory]_OBJS:.o=.d)

\endcode
In this type of expression, [directory] represents the mangled name 
of a directory, and [directory])_OBJS is the name of a makefile 
variable that lists all of the object file targets in that directory. 
The expression ([directory]_OBJS:.o=.d) uses a makefile text 
manipulation operator to replace the .o file extension in each file 
in this list by .d extension, thus creating a corresponding list of 
dependency files.  The effect of this include directive is thus to 
instruct make to attempt to include the *.d dependency files associated 
with each of the object files listed in variable [directory]_OBJS.  
The dash in front of the "include" keyword instructs make to continue
quietly if any particular dependency file does not yet exist.

<BR>
\ref developer_build_list_page   (Prev) &nbsp; &nbsp; &nbsp; &nbsp;
\ref developer_page              (Up)   &nbsp; &nbsp; &nbsp; &nbsp;
\ref developer_build_config_page (Next)

*/
