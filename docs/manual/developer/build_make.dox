/*! \page developer_build_make_page Make and Makefiles 

\ref developer_build_add_page  (Prev) &nbsp; &nbsp; &nbsp; &nbsp;
\ref developer_build_files_page  (Next)
<BR>

The build system for PSCF uses the unix "make" command.  Understanding 
the build system thus requires some familiarity with make. The discussion 
of the make command given below is intended to serve as an initial 
introduction for those who have little or no experience with make.  
Much more complete documentation of make is provided by the
<a href="https://www.gnu.org/software/make/manual/make.html">online manual</a> 
for the GNU make command.

\section developer_build_make_command_sec Make command

The "make" command is a standard unix utility that is used to control
compilation and installation of software packages.  It is invoked from a
terminal command line by typing the command name "make", often followed
by one or more arguments that are known as "targets".  Each target 
specifies either the name of a file to create or a label for a specific
action.

Whenever make is invoked, it searches for an associated "makefile" that 
specifies the actions that can be performed by make when it is invoked
from the current working directory. This makefile must be a file named 
"makefile" or "Makefile" that is located in the current working directory 
(i.e,.  in the directory from which the make command was invoked). Each
possible target that may be given as an argument of the make command 
must be the name of a "rule" in the associated makefile.

\section developer_build_make_rules_sec Makefile rules

A makefile usually contains a set of "rules".  Each rule provide 
instructions for how to perfom a specific action or type of action, and 
may contain information about the dependencies among different files. The 
general syntax for a makefile rule is:
\code
target:  prerequisites
	recipe
\endcode
The "target" is a character string that may be either the name of a file 
that would be created by the associated action or a label that simply 
describes the purpose of the recipte.  The "recipe" associated with a 
rule is a unix shell command or a sequence of such commands that must be 
invoked to perform the action.  The "prerequisites" entry is a list of 
the names of files that are required as inputs to the recipe.  

The list of prerequisites must appear on the same line as the target, 
separated from the target by a colon.  The recipe must start on the line 
after the line containing the target, and may span one or more lines. 
In a rather peculiar quirk of makefile syntax, every line of a makefile 
recipe must start with an invisible tab character.

The simplest type of makefile rule is one in which the target is the name 
of an object file that is created by compiling a source file.  In this 
case, the list of prerequisites normally contains both the name of the 
associated compilable *.cpp or *.cu source file and the names of all 
of the *.h header files and (in some cases) template implementation 
(*.tpp) files that the source file directly or indirectly includes. In 
the simple cases, the recipe for such a rule could be a command that 
calls the compiler to compile the source file and create the target 
object file.

*Example:* Suppose A is the name of a C++ class that is defined in 
a header file A.h for which member functions that are defined in a
source file A.cpp in the current working directory. A simple makefile
rule for using the gcc compiler to create an associated object file
named A.o might look like this:
\code
A.o:  A.cpp A.h
	gcc -o A.o A.cpp
\endcode
The list of prerequisites for such a rule should include names of
all header files that are directly or indirectly included into the
source code file that is compiled. For example, if either A.h or
A.cpp contained a preprocessor statements to include the header 
file "B.h" that contains the definition of another class named B, 
then B.h would also need to be included in the list of prerequisites 
for the target A.o.

Makefile rules can contain the following three different types of
target:

   - **File name targets**, for which  the target is the name of a
     specific file that needs to be created by the build system, 
     such as an object, library or executable file.

   - **File patterns targets**, for which the target is given by a 
     filename pattern that, for example, might match any filename with 
     a specific file name extension.

   - **Phony targets**, for which in which the target is a label such
     as "clean" or "all" but that is neither a file name or a file name 
     pattern, but merely serves as a label for the rule.

Rules with targets that are file name patterns are referred to here 
as pattern rules. Pattern rules and phony targets are discussed in 
more detail below.

File name targets and phony targets may be used as command line
arguments of the make command. Use of file name target as an argument
of make indicates that the indicated file should be built or updated 
if necessary, by applying the associated recipe. Use of a phony 
target as a command line argument instructs make to first update 
any out-of-date pre-requisites of the phony action, and then apply
the associated recipe.

\section developer_build_make_outdated_sec Outdated targets

To avoid redundant work, the make utility keeps track of whether
files that are listed as targets of rules are outdated or up-to-date.
When a rule is invoked to build a target file, such as an object file, 
the recipe associated with the rule is actually applied if and only 
if the target file is out-of-date.  A target file is considered 
out-of-date if one of the files that is listed as its pre-requisistes 
been modified since the last time the target file was modified. Thus,
if a user were to invokes the rule to build particular target twice 
in a row, without editing any C++ files in between, make would not 
apply the recipe to build the target file the second time, because 
it would know that the target file is already up-to-date. 

The decision regarding when the target of a rule is outdated is based on 
examination of file time stamps for files listed as pre-requisites.  
Time stamps are metadata associated with files in a unix file system that 
indicate the most recent time that a file was modified, and when the file 
was first created.  An existing file that is the target of a makefile rule 
is considered out-of-date if any file listed as a prerequisite of that 
target either: (a) is a file that has been modified since the last time 
that the target file was created or modified, or (b) is the target of 
another makefile rule that can be shown to be out-of-date by examination 
of the prerequisites of that rule. A target file that does not yet exist 
is always considered to be outdated, as are phony targets (targets that 
are not file names).

In a system with properly constructed pre-requisites, the rule to 
construct a *.o object file by compiling an associated *.cpp or *.cu
source file should list all of the header files that are directly or 
indirectly included by the source file. If a header file is directly 
or indirectly included by multiple source files, then modification of 
that header will cause all of the associated object files to become 
outdated.

\section developer_build_make_recursive_sec Recursive application of rules

When a makefile rule is invoked, the make command checks if any of 
the files listed pre-requisites of that rule are out-of-date targets
of other rules. If any pre-requisite files are found to be out of 
date, make first recursively applies any rules required to update 
all out-of-date out-of-date prerequisite files, and only then 
performs any actions specified by the recipe for the original rule. 
This behavior can cause invocation of a rule that builds one file 
to cause to a cascade of actions that build other related files.

As an example of this behavior, consider the case of a rule that
builds an executable file. The rule for constructing an executable
file often has a recipe that links an object file to one or more
library files, and a list of prerequisites that includes the object
file and the required libraries. Each library file may itself be
the target of a rule that lists the object files that the library
contains as prerequisites.  Each of those object files is the target
of a rule that compiles a corresponding source file, with a 
prerequisite list that includes the source file and all of the
header files that are directly or indirectly included by the 
source file. Invocation of a rule to build an executable file can 
thus cause the make utility to first compile a set of related 
source files to create or update any outdated object files, then 
use an archiver to create or update any outdated library files, 
and finally use a linker to create the requested executable file.

\section developer_build_make_pattern_sec Pattern rules

A pattern rule is typically used to specify a general procedure for 
creating any target file with a specific file extension by applying
a specific recipe to any corresponding files with the same base name 
but a different file name extension. The target of a pattern rule
must contain exactly one instance of the wildcard symbol \%, which 
may be matched by any continuous string of charcters. The \% symbol
may also used in one or more of the pre-requisites of a pattern rule 
to represent the same string as the one that matches \% in the 
pattern for the target.
For example, a rule with a target and prerequisite of the form
\code
%.o: %.cpp
	recipe...
\endcode
specifies how make any object file with of the form name.o from a
source and header file with the same base name, with names of the
form name.cpp and name.h. 

Other automatically defined variables may be used in the recipe
associated with a pattern rule to refer to the target and various
prerequisites. Specifically, the symbol $\@ refers to the target,
$< refers to the first pre-requisite, and $^ refers to a list of
all pre-requisites separated by spaces. 

Rules for building individual files can be combined with pattern rules
to concisely define build instructions. PSCF makefiles generally
include a specific rule for each relevant *.o object file target in
which the rule lists all of the prerequisites of that target file but
does not explicitly specify a recipe. In this case, no recipe is
required because make can infer the required recipe from a related
pattern rule for which target file name matches the target pattern.

More detailed documentation of pattern rules is available 
<a href="https://www.gnu.org/software/make/manual/html_node/Pattern-Rules.html">
here </a>.

\section developer_build_make_phony_sec Phony targets

A makefile rule target that is not a file name or a file name pattern 
is referred to as a "phony" target. Rules with phony targets are used 
to label an action that is not designed to build a specific target 
file. Invoking make with an argument that is the name of a phony target 
always causes the make to rebuild any outdated pre-requisites of that 
target and then apply any associated recipe.

PSCF makefiles generally contain several standard phony targets.  Every 
makefile contains named "all" and "clean". Upper level and namespace 
level directories generally have a targets named "veryclean". The 
purposes of these standard targets are:

   - "all" builds all of the target files that the makefile is
     responsible for constructing.

   - "clean" removes any files that were generated by making 
     the "all" target.

   - "veryclean" removes files that were generated either by
     calling the configure script or by running making "all".

The "all" target generally specifies a list of prerequisites but but 
no recipe.  Invocation of the "all" rule thus causes make to rebuild 
any out-of-date prerequisites of the rule. The list of pre-requisites 
of the "all" target normally includes all of the file targets that 
the makefile is responsible for constructing. These

The "clean" and "veryclean" targets instead generally include recipes 
but no pre-requisites. Invoking either of these rules simply causes 
make to apply the recipe, which removes files created previously by 
the build system.

Makefiles can specify that particular targets are phony (i.e., do not 
correspond to file names) by listing them as prerequisites of a 
standard built-in target named .PHONY. Thus for example, a makefile 
with three phony targets named "all", "clean" and "veryclean" could 
include a rule of the form
\code
.PHONY: all clean veryclean
\endcode
as a way of declaring that these three names are phony targets.  The 
effect of the .PHONY rule is to guarantee that the names of each 
pre-requisite will be treated as a phony target even even if a file 
with that name were found to exist.

\section developer_build_make_var_sec Makefile variables

Makefiles may define and use variables. Each makefile variable is
a symbolic name for a character string, which is known as the value
of the variable.  By convention, almost all variable names used in
PSCF are strings of upper case letters and underscores, such
SRC_DIR.

An expression for assigning a value to a makefile variable 
contains the name of the variable on the left of an equals sign
and the value to the right. For example,
\code
ROOT_DIR = /users/smith/pscfpp
\endcode
assigns an absolute path string as the value of variable ROOT_DIR.

A reference to the value of a variable is represented by a symbol
in which the variable name in enclose in parentheses and a $ sign
is placed before the opening parenthesis. For example, the symbol
$(ROOT_DIR) represents the value of the variable ROOT_DIR.  
References to makefile variable values may be used on the right
hand side of assignments and in other makefile expressions. For
example, the makefile variable SRC_DIR is assigned a value by the 
expression
\code
SRC_DIR = $(ROOT_DIR)/src
\endcode
in which $(ROOT_DIR)$ is expanded into the actual value of ROOT_DIR 
(i.e., the path to the PSCF root directory) and then concatenated 
with the string "/src" to obtain a string that is the path to the 
PSCF src directory.

\section developer_build_make_make_include_sec Makefile include directive

Makefiles can use the "include" directive to include other make files 
or makefile fragments. For example, the directive
\code
include $(SRC_DIR)/pscf/sources.mk
\endcode
would cause the sources.mk file in the PSCF src/pscf directory to be 
copied verbatim into the current makefile.

\section developer_build_make_default_sec Default targets

When make is invoked with a single argument that is the target of a 
makefile rule, and that target is either the name of a outdated file 
or a phony target, then the make command will execute the action 
associated with that rule.  For example, 
\code
make clean
\endcode
will cause make to apply the recipe associated with the "clean" target 
in the associated makefile. 

If make is invoked without any argument, by typing
\code
make
\endcode
on a line by itself, then, by default, the make command invokes the 
first rule in the associated makefile, which is known as the default
rule.  

The default rule in every makefile in the PSCF repository has a phony 
target named "all".  In the PSCF build system, the commands "make" and 
"make all" thus always have the same effect. The effect of the default
"all" target is generally to create or recreate all of the main targets 
of the makefile and (if necessary) all of their outdated pre-requisites.

<BR>
\ref developer_build_add_page  (Prev) &nbsp; &nbsp; &nbsp; &nbsp;
\ref developer_build_page           (Up)   &nbsp; &nbsp; &nbsp; &nbsp;
\ref developer_build_files_page   (Next)

*/
