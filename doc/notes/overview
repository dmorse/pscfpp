Chemistry
---------

These classes and class templates are used to describe molecular 
structures, and are common to all SCFT implementations:

    Monomer
    Vertex
    BlockDescriptor
    BlockTmpl<Propagator> : public BlockDescriptor
    Species
    PolymerTmpl<Block> : public Species
    MixtureTmpl<Polymer, Solvent> 

Each implementation of SCFT defines its own Mixture, Polymer, Block 
and Solvent class, each of which is derived from one of the classes
or class templates listed above. Mixture is derived from MixtureTmpl
template, Polymer from the PolymerTmpl, Block from the BlockTmpl,
and Solvent from Species.

In each implementation, a Mixture contains arrays of Monomer, Polymer,
and Solvent objects, and a Polymer contains arrays of Block and Vertex
objects. Each Monomer, Vertex, Block, Polymer, and Solvent class has an 
id that corresponds to its array index in such an array.

The Block and Vertex classes contain information that specify the graph
structure for an acyclic polymer.  A Block has the ids of the two vertices 
to which it is attached and the id of the associated monomer type. A 
vertex has the ids of the blocks to which it is attached.  Vertices can
represent either chain ends or junctions of two or more blocks. 

The Species class contains protected members to indicate the ensemble 
(Open or Closed) and the volume fraction phi or chemical potential 
mu of the species. 

Solver Templates
----------------

These templates are base classes for modified diffusion equation
solvers, containing the data structures and algorithms that should
be common to all implementations of SCFT.

    PropagatorTmpl
    BlockTmpl<Propagator>
    PolymerTmpl<Block>
    MixtureTmpl<Block>

Each implementation is defined in a separate namespace, and defines 
the following concrete classes:

    class Propagator : public PropagatorTmpl<Propagator>
    class Block : public BlockTmpl<Propagator>
    class Polymer : public PolymerTmpl<Block>
    class Solvent : public Species
    class Mixture : public MixtureTmpl<Polymer, Solvent>

Each of these is discussed in more detail in further below. The 
Propagator class must define typedefs named WField and CField which 
are aliases for classes that represent a chemical potential field 
or monomer concentration field, respectively, for one monomer type. 

Fields
------

The 1D finite difference implementation of SCFT in namespace Fd1d and
directory fd1d thus far defines both WField and CField to aliases for
a DArray<double> array container type. We envision that other 
implementations may define a specialized Field class that provides 
some additional methods that are not provided by DArray<double>. The
WField and CField may be defined either as subclasses of Field, or
simply as

Base class:

   class Field<T>
   class WField : public Field<double>
   class CField : public Field<double>
   class QField : public Field<double>

   Base on DArray<double> (derived or copy and paste)
   Provide methods or global functions:

      1) Assignment to another field (standard operator)

      2) Assignment to constant at all points: operator = (double& const T)
         Used in Propagator::computeHead to initialize vertices to 1
         Used in Block::computeConcentration to initialize to 0.0

      3) Multiplication by a scalar constant: operator *= (double& const )
         Used in Block::step() to scale by prefactor
         Used in Block::computeConcentration() to scale by prefactor

      4) Addition of fields, operator +=
         Standard operation for abstract vectors.

      5) Pointwise multiplication of fields, operator *= (Field<T>)
         Used in Propagator::computeHead to multiply source fields

      6) Inner product, method provided by Domain class.
         Used to compute Q in propagator computeQ()

SCF Solvers (General)
---------------------

   Each implementation (one-dimensional finite element, psuedo
spectral, etc) has a set of MDE solver classes that also contain
chemical information.  The solvers class system is based in part 
on C++ templates, rather than run time polymorphism alone.

   class Propagator : publiic PropagatorTmpl<Propagator>
      Has q(r,s) data structure, pointers to Block.
      Defines typedefs WField and CField.
      Provides a solve() method, which uses the step() method
      of the associated block.

   class Block : public BlockTmpl<Propagator>
      Has a pair of Propagator objects (one for each direction).
      Has a monomer concentration field for the block, and kuhn length.
      Has data structures used to compute both propagators for one block,
      including ns_, ds_ and any necessary work arrays.
      Provides step() and computeConcentration() methods.

   class Polymer : public PolymerTmpl<Block>
      Has arrays of Block and Vertex objects.
      Defines topology of an acyclic polymer.
      Provides a compute() function that calls solve for all
      propagators and computes concentrations for all blocks.

   class Solvent : public SolventDescriptor
      Implements a simple Boltzmann solver for a point particle.

   class Mixture : public MixtureTmpl<Polymer, Solvent>
      Has arrays of Monomer, Polymer, Solvent objects
      Provides a compute function that takes a const reference to 
      an array of WField objects as an input and a non-constant 
      reference to an array of CField objects as an output.

   class System

      Main simulation object. Has a Mixture as well as other main
      classes, as discussed below. Provides a readParameters() method
      to read entire parameter file and a readCommands method to read
      a command file.

   Remark: We will make wFields_ and cFields_ members of the System, 
   rather than of the mixture, and require the compute() method of 
   the mixture to take these as arguments. This yields an increase 
   in flexibility for Newton-Raphson style iterators with no loss 
   of speed.

1D Finite Difference
--------------------

   For 1D finite difference:

   namespace Scf {
   namespace Fd1d {
      class System {
         Mixture
         Domain
         Interaction (chi parameters)
         Iterator
         DArray<WField> : chemical potential fields
         DArray<CField> : monomer concentration fields
      }
   }
   }


Pseudospectral, periodic
------------------------

   For pseuddospectroal, periodic with symmetry constraints:

   namespace Pscf {
   namespace PsSp {
      System {
         Mixture
         Interaction (chi parameters)
         UnitCell
         SpaceGroup
         Mesh
         Basis
         Iterator
      }
   }
   }

   Questions / comments about periodic pseudospectral code:

   1) Basis must provide methods to convert basisToGrid and gridToBasis.
   Where will the basis representation be stored? Where will these 
   functions be defined (global functions or member functions?)

   Tentative choice: Make these member functions of the Basis object.

   2) How to handle different dimensions in C++ ? It would be nice to 
   have only one code, even if it needed to be recompiled. 

      - The simplest solution would be to use a preprocessor macro. 
        This, however, would make it impossible to have different
        objects with different dimensions in the same code.

      - The most flexible, but more verbose, solution would be to 
        make all relevant class templates with Dimension as a template
        argument.

   Choice: Use templates. Perhaps choose from among dimensions using 
   a command line option -d of the main program. For example:

   >  pscf_ps -d 3 -p param -c command 

   for a 3 dimensional computation.
   ---------------------------------------------------------------------

