/*! \page user_compile_page 2.1 Compiling 

\ref user_usage_page (Next) 
<BR>

The C++ version of PSCF is distributed only as source code, and must be compiled by the user. All source code is written in C++, and complies with the ANSI 1998 C++98 standard.  The package has been developed and tested using the gcc and intel compilers in a linux environment, and with the gcc compiler in Mac OS X.  It should compile with any modern, standard compliant C++ compiler.   

This C++ version of PSCF is an incomplete work in progress. Currently, it only provides a one-dimensional finite element implementation for planar, cylindrical or spherically symmetric geometries. 

The only external dependence of the code is currently a dependency upon the Gnu Scientific Library (GSL). This library must thus be be installed on your computer before compiling PSCF.

The build system uses unix makefiles, and is thus designed to work only in unix-like environments (i.e., gnu/linux or Mac OS X). It was developed using the gnu version of make (gmake), which is the default on all modern linux distributions and on Mac OS.

\section compile_getcode_section Getting the source code

The source code for PSCF is hosted on the University of Minnesota at <a href=http://umn.github.com>github server</a>, as a private project morse012/pscfpp.  The source code may be obtained by using a git client to clone the public <a href=https://github.umn.edu/morse012/pscfpp>git repository</a>.

Using Git: Before attempting to use git to clone the source code, first check whether the "git" executable is installed on your machine, by entering 
\code
> which git
\endcode 
If this does not return a valid path, it means that your computer does not recognize the "git" command, and that you thus need install git. 

To obtain a read-only clone of the git repository, via the read-only "git" communication protocol, you should change directory (cd) to the directory you want to contain the pscfpp root directory, and enter:
\code
> git clone git://github.umn.edu/morse012/pscfpp.git
\endcode
This will create a working copy of the source code in a new subdirectory named "pscfpp/". 

Users that want to be able to use github to manage their own changes to the code, or who would like to be able contribute their additions to the project should instead 
<ol>
<li> Log on to github.umn.edu (using the UMN x500 credentials), and create a user account. <\li>
<li> Create a user fork of pscfpp on their own github account. <\li>
<li> Create a local clone of their own fork of pscfpp using a communication protocal that allows read-write access, such as ssh or https. <\li>
<\ol>

Herefafter, we assume that the root project directory is named pscfpp/.  References to paths that do not start explicitly with a prefix "pscfpp/" should be understood to be relative paths, relative to this directory. The directory structure is explained \ref source_directory_page "here".

\section compile_dependencies Installing dependencies

Before attempting to compile PSCF, you must install the Gnu Scientific Library (GSL). The code will eventually also require FFTW, but this is not yet needed. It is possible to install either package either by compiling from source or (preferably) by using the appropriate packgage manager for your system.

If you are using a unix system, the most maintainable method is to use the appropriate package manager for your linux distribution (e.g., for Ubuntu or Fedora) to install the gsl library and (later) the fftw library.

If you are using a OS X mac, we recommend installing either the Homebrew or MacPort system (but not both!) to maintain ports of systems that were originally designed for unix, and then using this to install GSL. I prefer Homebrew, but both work fine.

If you would like to compile GSL or FFTW from source, go to the project web page, download the appropriate tar file and follow instructions given with the package. 

\section compile_short_section Compiling - Short instructions

Here is a brief summary of instructions for compiling all of the PSCF programs:

   - Add the pscfpp/bin directory to the users PATH, and add the pscfpp/scripts/python to PYTHONPATH (as discussed \ref compile_environment_section "here").

   - cd pscfpp/ (i.e., cd to the pscfpp root directory)

   - ./setup

   - make all

Each of the above steps is discussed in more detail below.  The "setup" script must be run from the pscfpp/ root directory, and (if all goes well) should correctly identify the appropriate paths to the GSL header and library files.

\section compile_environment_section Setting environment variables

Before compiling any code, you should:

  - Add the absolute path to the pscfpp/bin directory to the PATH shell environment variable (the shell command search path)

  - Add the pscfpp/scripts/python directory to the PYTHONPATH environment variable (the python module search path)

To do this, if you are using a bash shell, you must add some variant of the following lines to your the .profile or .bash_profile file in your user home directory:
\code
PSCF_DIR=${HOME}/pscfpp
export PATH=${PATH}:/${PSCF_DIR}/bin
export PYTHONPATH=${PYTHONPATH}:/${PSCF_DIR}/scripts/python
\endcode
The value of PSCF_DIR should be set to the path to the pscfpp root directory. In the above example, this is assumed to be a subdirectory of the users home directory. After adding an appropriate variant of these lines to .profile or .bash_profile, log out, log back in, and then enter "echo $PATH" and "echo $PYTHONPATH" to make sure that these variables have been set correctly. 

Explanation: The pscfpp/bin directory is the default location for installing executable files created by the build system. This must be added to the users PATH to allow the operating system to find the executable files needed to run a simulation. The pscfpp/scripts/python directory contains a python script that is used by the build system to generate information about dependencies among C++ files, as discussed in more detail \ref compile_dependency_section "below".

\section compile_setup_section Initial setup

After installing GSL, and before compiling any code, you must run a bash script named "setup". This script is located in the pscfpp/ root directory, and must be executed from this directory. 

The setup script uses a program named "gsl-config" to locate paths for header and library files needed by the Gnu Scientific Library. This program should have been installed when GSL was installed. To check that this program exists and is in the command path, try entering
\code
> which gsl-config
\endcode
if this returns a valid path to a file named gsl-config, such as "/usr/bin/gsl-config", then all is well and you may continue. If not, you have not installed GSL, or something is wrong with the installation.

After confirming that gsl-config exists, then change your working directory (cd'ing) to the pscfpp/ root directory, and enter:
\code
> ./setup
\endcode
Explanation: The setup script creates several configuration files that are required for compilation. These are all files that users may need to modify in order to customize or extend the program, and that are thus not stored in the git repository. The script works by making copies of default file versions that are stored in the repository under slightly different file names. The setup script should only need to be invoked once, before the first time you compile. Because it creates files that contain absolute paths, you would also need to run it again if you move the pscfpp/ directory.

\section compile_inoutsource_section Building "out-of-source" vs. "in-source"

The pscfpp makefile system can build the package either "out-of-source" or "in-source". When the package is built "in-source", object files, static library files and other non-executable files that are generated during compilation are placed in the src/ directory tree, alongside the corresponding C++ source files. When it is built "out-of-source", these generated files are placed in a separate "build" directory tree, outside the source tree. In either case, the executable files for all programs are installed in the pscfpp/bin directory. We recommend that most users build the package out of source. 

To perform a standard "out-of-source" build of any pscfpp program, simply invoke "make all" from the pscfpp/ root directory, as described in the above short instructions. The main makefile in the root directory will automatically build out-of-source.

To peform an in-source build of any program, one must instead invoke "make" with an appropriate target from the pscfpp/src/ directory, rather than from the pscfpp/ root directory. In addition, invoking the command "make all" from almost any subdirectory of the src/ directory tree will also compile all C++ files in the tree rooted at that directory. Developers often find it convenient to compile in-source when working on new code. 
 
Hereafter, unless stated otherwise, we will assume that all programs are built out-of-source by invoking make from the pscfpp/ root directory.

\section compile_build_directories_section Build configuration files

The src/ and bld/ director each contain the directory structure and the set of makefiles required to build any version of pscf. In what follows, we will refer to these three directories collectively as build directories. Each of these build directories contains a tree of subdirectories identical to that of the src/ directory. After setup (i.e., after the setup script has been run), each build directory tree also contains several makefiles and a set of build configuration files. 

The build configuration files are all named "config.mk". The main build configuration file is the file named config.mk in the root directory of the build directory tree (i.e., in bld/ or src/). In addition the top level subdirectories of each build directory each also contains a configuration file named config.mk. The config.mk files in each build directory together specify the configuration of any code compiled in that directory. Specifically, they specify which compiler will be used, what command line options will be passed to the compiler, and which optional features will be enabled or disabled in any code compiled in that build directory tree. These files are makefile fragments that are included by the actual makefiles. Users may change the configuration before compiling either by: (1) manually editing these configuration files, or (2) by using a script named "configure" to enable or disable specific features. We recommend using the configure script (discussed in more detail \ref compile_configure_section "below") to change configuration whenever possible, but some changes require manual editing.

The src/ directory also contains a corresponding set of 6 files named config.mk_r. Each of these is a default version of a corresponding config.mk file. Only the config.mk_r files are stored in the git repository (the suffix _r stands for "repository"). Initial versions of the config.mk files are created in all build directories by the setup script by copying the config.mk_r files. Users may modify the config.mk files as needed, but should avoid modifying the config.mk_r default versions.

\section compile_compiler_section Choosing a compiler

The choice of what compiler command to use, and what options to pass the compiler, are specified in the main config.mk file in each build directory. By default, the build system uses the gnu compiler collection (gcc) C++ compiler, using a reasonable set of default compiler options, with aggressive optimization. If you are satisifed with the gcc compiler and these compiler options, you can skip the rest of this section.

If you prefer to use the intel compiler (and if it is installed on your computer), enter the command
\code
> ./configure -j intel
\endcode
from the pscfpp/ root directory and/or the pscfpp/src directory. Entering this command from the pscfpp/ directory selects the intel compiler for use in all out-of-source builds. Entering this command from the pscfpp/src directory selects the intel compiler for use in in-source builds. To explicitly choose the gcc compiler (e.g., after choosing the intel compiler and then changing your mind), instead enter "./configure -j gcc".

Details: The choice of compiler for use in each build directory is specified by the value of a makefile variable named COMPILER that is defined the main config.mk configuration file in that directory. Thus far, the only valid values for this identifier are "gcc" or "intel". The default value, COMPILER=gcc, selects the gnu C++ compiler, for which the compiler command name is "g++". Setting COMPILER=intel selects the intel C++ compiler, for which the compiler command is "icpc".  The value of the COMPILER variable is used to select a block of definitions of other variables that define which command line options should be passed to a specific compiler. To change the options passed to a particular compiler, one must manually edit the values assigned to these makefile variables in the main config.mk file. Users who wish to do this should read the documentation in config.mk file, which explains the purpose of each of the relevant makefile variables. Users who are comfortable with makefiles should also find it straightforward to extend this file so as to allow use of compilers other than the gcc and intel compilers.

\section compile_configure_section The configure script (build directories)

Each build directory (i.e., bld/serial, bld/parallel, and src/) contains a bash script named "configure" that can be used enabled or disable specific compile time features. The configure script does its work by editing the build configuration files, which control what options will be passed to the compiler during any subsequent compilation. The configure script in each build directory must be invoked from the directory that contains the script (i.e., from bld/serial, bld/parallel, and src/), and only affects the configuration of code that is compiled in that build directory.

The -q command line option of the configure script may be used to query which optional features are currently set to be enabled or disabled. To see how this works, after the setup script has been run, cd to the bld/serial directory and enter
\code
> ./configure -q
\endcode
The -q command line option cause the script to print a list of which optional features are currently enabled, and the name of the current choice of compiler. The resulting output for the default configuration should look something like this:
\code
-m OFF - MPI
-g OFF - debugging
-k ON  - automatic dependency tracking
COMPILER:=gcc
\endcode
Each line of this output except the last shows whether an optional feature is currently set to be enabled (ON) or disabled (OFF). The last line gives an identifier (the value of COMPILER) for the current compiler (gcc, by default). The output produced by running the configure script in the bld/parallel directory looks similiar, except that it should indicate that MPI is ON (enabled).

Each line of this output except the last begins with the name of the command line option for the configure script (a dash followed by a letter) that can be used to enable or disable an associated feature. For example, the "debugging" feature is enabled or disabled using the "-g" option. Each feature can be enabled by using the associated command line option followed by "1" (ON), or disabled by using the option followed by "0" (OFF). 

For example, to enable debugging (which enables extensive run-time sanity checks, at some cost in speed) in code built in one build directory, one would enter
\code 
> ./configure -g1
\endcode
from the root of the relevant build directory. Running "./configure -q" again after this change would show that debugging is now enabled. This and any other desired changes must be made before invoking make to compile a program. To disable debugging, one would instead enter
\code 
> ./configure -g0
\endcode
and then recompile. All of the available optional features are discussed \ref user_options_page "here". 

As noted above, configure script may invoked with the -j option to set the value of the COMPILER identifier string, which chooses a compiler. This option takes the desired value of the COMPILER identifier (gcc or intel) as an argument. 

\section compile_root_configure_section The configure script (root directory)

The pscfpp/ root directory also contains a bash script named "configure" that can be used to apply changes simultaneously to the bld/serial and bld/parallel directories. This version of the script must be invoked from the root directory. It accepts the same options as the configure scripts in the build directories, with one exception: It does not accept the "-m" option, which enables or disables MPI, because MPI should normally be enabled bld/parallel and disabled in bld/serial. The root directory configure script works by simply invoking the ./configure scripts in the bld/serial and bld/parallel directories. It does not effect the configuration of in-source builds. The output of this script echoes the outputs produced by the build-directory configure scripts. The "-q" option can be used to show the current configuration in both subdirectories of bld/.

\section compile_suffix_section Executable File Name Suffixes

Users may want to maintain several versions of a program with different features enabled or disabled. To make this possible, the pscfpp build system uses a system of file name suffixes to distinguish different versions of a program. Whenever a feature that is disabled by default is enabled, the build system adds a suffix to the name of all affected executable files to indicate the change. For example, the executable file for a version of mcSim that was compiled with debugging enabled, but no other non-default features, would be called mcSim_g. The suffix "_g" is used indicate that debugging is enabled in that executable. The same convention is used in the names "mcSim_m" and "mdSim_m" of the multi-processor versions of mcSim and mdSim, in which the suffix "_m" is used to indicate that these programs were compiled with MPI enabled. In most cases, the file name suffix associated with an optional feature is a underscore followed by a single letter that is the same as the letter in the command line option of the configure script that is used to enable or disable that feature. 

The use of this convention requires users to understand the relationship between features and file name suffixes in order to invoke the correct executable name when running a simulation. For example, a user needs to know to invoke "mdSim_g" to run a version of mdSim with debugging enabled (which can be helpful during development) but to invoke "mdSim" to run the faster "production" version. We recommend that users read page \ref user_options_page before compiling programs with any non-default features enabled. We also recommend that users get in the habit of listing the contents of the pscfpp/bin directory before and after building programs with non-default features enabled, to make sure they know the names of the executable files that they have created, and so can invoke them correctly to run simulations.

\section compile_doc_section Generating html documentation

The html documentation you are reading was generated using the <a href=http://www.doxygen.org> doxygen </a> documentation utility. Neither the git repository nor the downloadable version of the source code contain the resulting html files. If doxygen is installed on your machine, you can regenerate a local copy of the html documentation by entering
\code
> make html 
\endcode
from the root directory. The resulting html files will be installed in the pscfpp/doc/html/ directory. 

The main page of the html documentation is a file named doc/html/index.html. To begin reading the documentation, open this file in any web browser, e.g., by entering 
\code
> firefox doc/html/index.html
\endcode
from the pscfpp/ directory to use the firefox browser on linux, or entering
\code
> open doc/html/index.html
\endcode 
to use the default browser on a Mac.

The text of the page you are now reading, along with other main manual pages, is contained in a set of files with file extension *.dox in the doc/manual directory. These are written in plain text, and can also be read with any text editor. Additional API documentation for each C++ class is extracted by doxygen from documentation blocks in the class header file. 

To delete all html documentation from the doc/html directory, enter
\code
> make clean-html
\endcode
from the pscfpp/ root directory.

\section compile_dependency_section Automatic dependency generation

By default, the pscfpp build system automatically generates a "dependency" file, with a suffix *.d, whenever it compiles a *.cpp source file. The dependency file is placed in the build directory tree in same directory as the corresponding object *.o file. 

The system for generating dependency files uses the g++ compiler, which does the actual analysis of dependencies among C++ files, and a python script named pscfpp/scripts/python/makeDepend.py. To function, the system requires that:
 
  - A g++ compiler (or a link with this name) must be in the user's PATH environment variable

  - A python interpreter must be in the user's PATH

  - The pscfpp/scripts/python/ directory must be in the PYTHONPATH environment variable

Note that the g++ compiler is used for dependency analysis even if another compiler (e.g., the intel compiler) is used for compilation. A g++ compiler and python interpreter is normally available on any modern linux distribution and any Mac OS X environment that is correctly set up for C++ development.

Automatic generation of dependency files is an essential feature for developers - It makes it possible to safely rebuild a program after you modify one or two files, and have the build system recompile only what needs to be recompiled. This feature is not, however, strictly necessary for users who simply want to compile one version of the code and use it as is, without modifying any C++ files.  It is possible to disable automatic dependency generation in any build directory by entering "./configure -k0" from the root of that build directory. The only good reason to do so is as a temporary measure if you run into trouble that you suspect arises from a problem in the dependency generation system, e.g., if compilation fails because the operating system cannot find a python interpeter or if python cannot find the makeDepend.py python script. If the PATH and PYTHONPATH are set correctly, however, this should not be necessary.

<BR>
\ref user_page   (Up) &nbsp; &nbsp; &nbsp; &nbsp; 
\ref user_usage_page (Next) 

*/
