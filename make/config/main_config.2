# ======================================================================
# General definitions for all systems (Do not modify)

# Choices that depend on whether debugging is enabled
ifdef UTIL_DEBUG
   # Flags for serial programs with debugging
   CPPFLAGS+= -D UTIL_DEBUG
   CXXFLAGS=$(CXXFLAGS_DEBUG)
else
   # Flags for serial programs with no debugging
   CXXFLAGS=$(CXXFLAGS_FAST)
endif

# Initialize INCLUDE path for header files (must include SRC_DIR)
# This initial value is added to in the patterns.mk file in each 
# namespace level subdirectory of the src/ directory.
INCLUDES= -I$(SRC_DIR)

#=======================================================================
# Automatic dependency generation.
 
# Names of scripts invoked to compute dependencies among header files.
MAKEDEP=$(BIN_DIR)/makeDepCpp
MAKEDEP_CUDA=$(BIN_DIR)/makeDepCuda

# The files $(BIN_DIR)/makeDepCpp and $(BIN_DIR)/makeDepCuda are 
# executable python scripts that are installed in the $(BIN_DIR) by
# the configure script.  These scripts are used during compilation to 
# analyze dependencies among source and header files, and create *.d 
# dependency files. Both scripts import a python module named pscfpp.make 
# that is located in the $(ROOT_DIR)/lib/python/pscfpp directory. For 
# the python interpreter to find this, directory $(ROOT_DIR)/lib/python 
# must be in the users PYTHON_PATH environment variable.

# ======================================================================
# Makefile Pattern Rules and Recipes
#
# The makefile variables defined above are used in the makefile rules 
# that control compilation of C++ files, creation of libraries, and
# linking to create executables. The following sections briefly explain
# these rules, to provide a context for the meaning of the variables 
# defined above.
#
#-----------------------------------------------------------------------
# Compiler Pattern Rules:
#
# The top level subdirectories of src/ named util/, pscf/, prdc, r1d/, 
# rpc/ and rpg/ each contain the source code defined in a particular
# namespace, and are referred to here as namespace level directories.
#
# Each such namespace level directory contains makefile fragments named
# sources.mk and patterns.mk. The purposes of these files are as follows:
# 
#    sources.mk  defines a list of source files in the directory
#    patterns.mk defines pattern rules for compilation 
# 
# The makefile files within each namespace level directory includes the 
# sources.mk and patterns.mk files from that namespace level directory,
# and the sources.mk files from any other namespace-level directories on
# which this one depends.
#
# The use of a different patterns.mk rule in different namespace-level
# directory allows for the possibility of slightly different pattern rules
# in different directories. This freedom is currently not used in PSCF -
# identical pattern rules for C++ and CUDA C++ files are used in all
# namespace-level directories.
#
# Compiling *.cpp C++ files:
# --------------------------
#
# The compiler pattern rule for compiling C++ files for each namespace 
# level subdirectory of src/ is of the form:
# 
# $(BLD_DIR)/%.o:$(SRC_DIR)/%.cpp
#      $(CXX) $(CPPFLAGS) $(CXXFLAGS) $(INCLUDES) -c -o $@ $<
#
# This pattern compiles a *.cpp file in a subdirectory of the source
# directory $(SRC_DIR) and creates a *.o object file in a corresponding
# location in a subdirectory of the build directory, $(BLD_DIR). The 
# $(SRC_DIR) and $(BLD_DIR) are the same in the case of in-source 
# compilation. The variables used in this pattern are:
#
# CXX         - C++ compiler executable command name 
# CPPFLAGS    - options for the C/C++ preprocessor
# CXXFLAGS    - additional options used during compilation
# INCLUDES    - added directories to search for header files
#
# Values for the variables $(CXX), $(CPPFLAGS) and $(CXXFLAGS) are
# defined above in this main config.mk file.  The same values for these
# variables are used in all namespace level directories.
#
# The variable $(CPPFLAGS) defines flags that are used by the C/C++ 
# preprocessor. The may include the use of the -L option to add any
# directories that should always be searched for included header files.
#
# The variable $(CXXFLAGS) specify additonal flags that are used during 
# compilation of preprocessed code, and that are needed in all namespaces.
# This string always contains the $(CXX_STD) string, and may contain
# options that specify the optimization level and control warnings.
#
# The INCLUDES variable uses the -L option to list any additional paths 
# for header files, beyond any listed in $(CPPFLAGS). This always 
# includes the $(SRC_DIR) directory. 
#
# The INCLUDES variables is defined with the patterns.mk file in each
# namespace level subdirectory of src.
# 
# Compiling C++ CUDA (*.cu) source files:
# ---------------------------------------
#
# Source files that contain CUDA code are indicated by a file extension
# *.cu. In namespace level directories that contain such files, the
# patterns.mk file contains a pattern rule for compiling a *.cu file to 
# create a corresponding *.o file. The rule for compiling *.cu files is 
# closely analogous to that used for *.cpp files, and is of the form:
# 
# $(BLD_DIR)/%.o: $(SRC_DIR)/%.cu
#      $(NVXX) $(CPPFLAGS) $(NVXXFLAGS) $(INCLUDES) -c -o $@ $<
#
# This contains the two new makefile variables that are analogous to 
# CXX and CXXFLAGS:
#
# NVXX        - CUDA compiler executable name (nvcc)
# NVXXFLAGS   - compiler options used during compilation
#
# The makefile variables $(CPPFLAGS) and $(INCLUDES) have the same
# meanings and values as in the rule for *.cpp files. 
#
#-----------------------------------------------------------------------
# Archiver Recipes:
#
# The PSCF build system creates a static library in each namespace-level
# subdirectory of the build directory that contains object code create
# by compiling all the class source files in that directory.  The makefile 
# rule to compile this library is defined in the sources.mk file in the 
# same directory. The rule for the Pscf::R1d namespace, as an example, 
# is of the form
#
# $(AR) rcs $(r1d_LIB) $(r1d_OBJS)
#
# where $(AR) is the name of archiver command used to create a library,
# $(r1d_LIB) is an absolute path for the resulting library file and 
# $(r1d_OBJS) is a string that contains absolute paths for all of the
# *.o object files created by compiling source files in the directory
# src/r1d. Rules for other namespace level directories are analogous.
#
#-----------------------------------------------------------------------
# Linker recipes for executable file targets:
# 
# Executable files are created by linking a compiled main program to a 
# required set of libraries. Recipes for creating executables are defined
# in namespace level makefiles. For example, the recipe for creating the 
# pscf_pc executable is defined in the file rpc/makefile within the 
# relevant build directory (bld/ or src/), and is of the form:
#
#    $(CXX) $(LDFLAGS) -o $(PSCF_PC_EXE) $(PSCF_PC).o $(LIBS)
#
# Here $(PSCF_PC_EXE) is the path to the executable, which is a file
# named pscf_pc in the $(BIN_DIR), $(PSCF_PC).o is the path to the object
# file that is created by compiling the src/pscf/pscf_pc.cpp main program
# program source file, and $(LIBS) is a variable that contains a list of 
# compiler options to include required libraries using the -l compiler
# option. Values for the paths to the executable file target and object
# file are defined in the relevant makefile, while the value of $(LIBS)
# is defined in the patterns.mk file in the same namespace-level 
# directory.
#
#=======================================================================
 
