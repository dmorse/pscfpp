namespace Pscf{
/*! 

\page pscf_AmIteratorTmpl_page Anderson Mixing Solver Algorithms

Many of the SCFT iteration algorithms and PS-FTS compressor algorithms
used by PSCF are based on some variant the Anderson mixing algorithm.
Anderson mixing (AM) is a general stategy for iteratively solving a 
nonlinear system of equations by taking advantage of information obtained 
during several previous iterations. PSCF C++ classes that use this 
strategy are all derived from a class template named Pscf::AmIteratorTmpl
that provides data structures and algorithms required in all variants of
this strategy. 

\section pscf_AmIteratorTmpl_problem_sec Problem statement 

Consider a system of \f$ N \f$ nonlinear equations that must be solved 
for \f$ N \f$ variables. Let \f$ {\bf X} \f$ denote a vector of unknown 
variables with elements \f$  X_{0}, \ldots, X_{N-1} ) \f$. 
We will refer to this vector of variables as a state vector.  We assume 
without loss of generality that the problem is expressed as a system of 
equations of the form
\f[
  R_{i}({\bf X}) = 0
\f]
for all integer \f$ i = 0, \ldots, N-1 \f$. Here, \f$ R_{i} \f$ denotes 
a single element of a residual vector \f$ {\bf R} \f$ with \f$ N \f$
elements \f$ (R_{0}, \ldots, R_{N-1} )\f$, such that each element of 
this vector is a function of the full state vector \f$ {\bf X} \f$. 

To describe a sequence of states generated by an iterative algorithm, 
let \f$ {\bf X}^{k} \f$ and \f$ {\bf R }^{k} \f$ denote values of the 
state vector and residual vector, respectively, at the end of iteration 
step \f$ k \f$, for \f$ k = 1, 2, \ldots \f$. Let \f$ {\bf X}^{0} \f$ 
and \f$ {\bf R}^{0} \f$ denote initial values, before the first iteration.

\section pscf_AmIteratorTmpl_algo_sec Anderson mixing algorithm

Each iteration of an AM algorithm consists of two steps, which we refer to 
as projection and correction. The projection step uses information from
previous iterations to produce an intermediate state, and the correction
step attempts to further reduce the error remaining in this intermediate
state.  To describe this, let \f$ \underline{{\bf X}}^{k} \f$ denote the 
intermediate value of the state vector obtained after the projection 
step of iteration \f$ k \f$ but before the correction step.

\subsection pscf_AmIteratorTmpl_algo_project_sub Projection step

We projection step uses information from previous states, and relies on 
and that the initial state vector is close enough to a solution that the 
function \f$ {\bf R}({\bf X}) \f$ is nearly linear. For each iteration 
\f$ k > 1 \f$, the projection step uses stored values of values of 
\f$ {\bf X}^{k} \f$ and \f$ {\bf R}^{k} \f$ at the current state and 
at \f$ K \f$ previous states to construct an intermediate trial state 
vector \f$ \underline{{\bf X}}^{k+1} \f$ as a linear superposition 
of the form
\f[
  \underline{{\bf X}}^{k+1} = {\bf X}^{k} + 
  \sum_{j=0}^{K-1} 
  ( {\bf X}^{k-j} - {\bf X}^{k-j-1} ) C_j \quad,
\f]
in which \f$ C_{0}, \ldots, C_{K-1} \f$ are real coefficients that will 
be optimized to minimize the norm an estimate of the resulting residual 
vector.  The parameter \f$ K \f$ grows by 1 after each iteration after
the first until it reaches a user-defined integer parameter 
\f$ N_{\rm h} \f$ that gives the maximum allowable number of previous 
states. A predicted value of the residual vector in this trial state, 
denoted by \f$ \underline{{\bf R}}^{k} \f$, is obtained by assuming 
linearity, giving a predicted residual vector
\f[
  \underline{{\bf R}}^{k+1} ={\bf R}^{k} + 
  \sum_{j=0}^{K-1} ({\bf R}^{k-j} - {\bf R}^{k-j-1} ) C_j \quad,
\f]
that is given by a corresponding linear superposition of previous
residual vector values. The values of the coefficients 
\f$ C_{1}, \ldots, C_{K-1} \f$ are chosen so as to minimize the
\f$ l_{2} \f$ norm of the predicted residual 
\f$ \underline{{\bf R}}^{k} \f$.
This corresponds to minimization of the linearized residual within 
a \f$ K \f$ dimensional subspace for the difference
\f$ \underline{{\bf R }}^{k+1} -{\bf R}^{k} \f$ that is spanned by a 
basis of
\f$ K \f$ differences between values of \f$ {\bf X} \f$ in previous 
states.  We refer to this as "projection" because it yields a change 
in the state vector that has been projected into this relatively low 
dimensional subspace.

\subsection pscf_AmIteratorTmpl_algo_minimize_sub Linear Least-squares problem 

As part of the the projection step discussed above, we must compute the
list of coefficients that minimize the norm of the residual. This is a
standard least-squares problem.  To discuss this, we define basis vectors
\f[ 
   {\bf Y}_{j} \equiv {\bf R}^{k-j} - {\bf R})^{k-j-1}
\f]
for \f$ j = 0, \ldots, K - 1 \f$, and express 
\f$ \underline{\bf R}^{k+1} \f$ as a sum
\f[
  \underline{{\bf R}}^{k+1} = {\bf R}^{k} + 
  \sum_{j=0}^{K-1} C_j {\bf Y}_{j} \quad.
\f]
The coefficients that minimize \f$ |\underline{\bf R}^{k+1}|^{2} \f$ must 
satisfy the criteria
\f[
  0 = \frac{\partial |\underline{\bf R}^{k}|^{2}}{\partial C_{i}}
    = 2 \frac{\partial \underline{\bf R}^{k}}{\partial C_{i}}
      \cdot \underline{{\bf R}}^{k} 
    = 2 {\bf Y}_{i} \cdot \underline{{\bf R}}^{k} 
\f]
for all \f$i = 0, \ldots, K - 1 \f$.
Expanding the resulting expressions yields a linear system of equations 
of the form
\f[
   \sum_{j=0}^{K-1} U_{ij}C_{j} = -V_{i}
\f]
in which we have defined a \f$ K \times K \f$ square matrix \f$ U \f$ 
and a column vector \f$ V \f$ with elements
\f[
   U_{ij} \equiv {\bf Y}_{i} \cdot {\bf Y}_{j}
   \quad\quad
   V_{i} = {\bf Y}_{i} \cdot {\bf R}^{k-1}
\f]
for \f$ i, j = 0, \ldots, K-1 \f$. 
The vector of coefficients that solves this problem yields a minimal 
value of the predicted residual \f$ \underline{{\bf R}}^{k+1} \f$ 
that is orthogonal to the \f$ K \f$ dimensional subspace spanned 
by \f$ {\bf Y}_{0}, \ldots {\bf Y}_{K-1} \f$. Once they are known,
these coefficients can also be used to compute trial state vector
\f$ \underline{{\bf X}}^{k+1} \f$.

\subsection pscf_AmIteratorTmpl_algo_correct_sub Correction step

The correction step adds an additional correction vector, denoted by 
\f$ {\bf D}^{k} \f$, to obtain a new state
\f[
   {\bf X}^{k+1} = \underline{{\bf X}}^{k+1} + {\bf D}^{k+1}
\f]
The value of the correction vector \f$ D^{k} \f$ generally depends 
upon the residual vector \f$ \underline{{\bf R } }^{k+1} \f$ that is 
predicted to remain after the projection step. The projection vector 
generally does not lie within within the \f$ K \f$ dimensional subpace 
in which the projection step attempts to minimize the residual.

The correction step proposed in the original Anderson mixing algorithm
uses a correction vector that is simply proportional to the predicted 
residual, giving
\f[
   {\bf D}^{k+1} = \pm \lambda \underline{{\bf R }}^{k+1} \quad,
\f]
where \f$ \lambda \f$ is user specified "mixing" parameter. By default, 
the Pscf::AmIteratorTmpl class template uses a slightly more 
complicated correction vector of the form
\f[
   {\bf D}^{k+1} = \alpha \lambda \underline{{\bf R }}^{k}
   \lambda = 
\f]
in which \f$ \alpha \f$ is a dimensionless "ramp factor" that increases 
over the first few steps of iteration and approaches \f$ 1 \f$ after an 
initial ramp-up period. This quantity is given by
\f[
    \alpha = 1 - r^{K+1}
\f]
for \f$ K < N_{\rm h} \f$ and \f$ \alpha = 1 \f$ otherwise, where
\f$ K \f$ is the current number of basis vectors, \f$ r \f$ is a
parameter in the range \f$ r \in [0, 1] \f$. The Pscf::AmIteratorTmpl 
temnplate uses default values of 
\f[
   \lambda = 1  \quad\quad r = 0.9
\f]
if the user does not explicitly set values for these parameters. 
The implementation provided by this template also allows the user
The default version of this algorithm also allows the user disable 
use of the ramp parameter (thus setting \f$ \alpha = 1 \f$ for 
every iteration), by setting a bool parameter named useLambdaRamp 
to false (or 0).

\subsection pscf_AmIteratorTmpl_algo_vary_sub Variations on a theme 

The descriptions of the problem statement and the AM algorithm given 
above are intentionally quite general.  In PSCF, classes that are derived 
from the Pscf::AmIteratorTmpl class template are used to implement both 
SCFT iteration algorithms and PS-FTS compressor algorithms.  SCFT 
iterators for periodic systems can be used either to solve the SCF 
equations in a fixed unit cell (which requires adjust of a set of w fields 
associated with different monomer types) or to simultaneously solve the 
SCF equations and optimize the unit cell parameters. PS-FTS compressor 
algorithms adjust a single pressure-like chemical potential field so as 
to satisfy a self-consistent field incompressibility constraint. These 
different types of problem require different definitions of the residual 
and state vectors, with different numbers of elements.

Different algorithms for solving the same problem may also define the 
residual vector different ways. The field equations that must be solved
in a SCFT problem can be written in a variety of equivalent ways that
correspond to different was of defining a residual vector. Iterator 
algorithms for periodic structures may also define elements of the 
residual vector either in real space, by associating each element with 
a specific node on a computational grid, or in Fourier space, by 
instead associating each element of this vector with a specific basis 
function in a symmetry-adapted Fourier series. 

To completely describe an algorithm that uses the AM strategy described
above, one must thus specify:

   - The definition of the residual vector \f$ {\bf R}({\bf X}) \f$

   - The choice of the correction vector \f$ {\bf D}^{k} \f$ that is 
     added during the correction step of the algorithm.

The design of the AmIteratorTmpl class template separates general and 
specific aspects of an AM algorithm, in part, by giving responsibility 
for operations that depend on the nature of the problem to a set of
pure virtual functions that must be implemented by subclasses. Among
these are a virtual functions that computes the value of the residual 
vector, and another that defines the correction vector \f$ D \f$ used 
during the update step.

\section pscf_AmIteratorTmpl_Error_sec Stopping criteria

The AM iteration loop defined by the AmIteratorTmpl template terminates 
either: (1) when the number of iterations reaches some user-specified 
maximum value, or (2) when the value of a scalar error \f$ e({\bf R}) \f$ 
becomes less than a user-specified error tolerance \f$ \epsilon \f$. 
The value of the error tolerance is always given by a parameter named 
"epsilon" in the parameter file.  The value of the scalar error is 
generally defined as a norm of the residual vector, as discussed below.

Users may usually choose from among several possible definitions of the 
erorr \f$ e \f$ by assigning one of the following allowed values to a 
string parameter named "errorType":

  - If errorType == "norm", then the scalar error is take to be the 
    \f$ l_2 \f$ norm of the residual vector \f$ {\bf R} \f$, i.e.,
    \f[
       e = |{\bf R}| = \left ( \sum_{i=0}^{N-1} R_{i}^{2} \right)^{1/2}
    \f]

  - If errorType == "rms", then the scalar error is take to be the 
    root-mean-square magnitude of elements of the residual vector (i.e.,
    the \f$ l_2 \f$ norm divided by the square root of the number of 
    elements),
    \f[
       e = \frac{|{\bf R}|}{\sqrt{N} }
         = \left ( \frac{1}{N}\sum_{i=0}^{N-1} R_{i}^{2} \right)^{1/2}
    \f]

  - If errorType == "max", then the scalar error is take to be 
    maximum absolute magnitude of any element in the residual vector 
    (i.e., the \f$ l_{\infty} \f$ norm of the residual vector).

  - If errorType == relNorm, then the scalar error is take to be the 
    ratio of the \f$ l_{2} \f$ norms of the residual vector and the 
    state vector,
    \f[
       e = \frac{|{\bf R}}{|{\bf X}|} \quad,
    \f]
    as in Stasiak and Matsen, Eur. Phys. J. E <b> 34 </b>, 110 (2011).

An iteration algorithm successfully converges if it terminates with
\f$ e({\bf R}) < \epsilon \f$ in fewer than the maximum allowed number
of iterations.  The choice of an appopriate value for the error 
threshhold \f$ \epsilon \f$ (or "epsilon") may depends on both the way 
that the residual vector is defined and the choice of an error type.

\section pscf_AmIteratorTmpl_Param_sec Algorithmic parameters

The parameter file formats for Iterator and compressor classes that 
are derived from the Pscf::AmIteratorTmp class template usually accept 
values for the following parameters, possibly among others:
<table>
  <tr>
    <td> <b> Label </b>  </td>
    <td> <b> Type </b>  </td>
    <td> <b> Description </b>  </td>
  </tr>
  <tr>
    <td> epsilon </td>
    <td> real </td>
    <td> Desired tolerance for convergence - iteration stops if the
         magnitude \f$ e \f$ of the error becomes less than 
         epsilon. (Required) </td>
  </tr>
  <tr>
    <td> maxItr* </td>
    <td> int </td>
    <td> Maximum number of iterations that will be attempted .
         (Optional, 200 by default) </td>
  </tr>
  <tr>
    <td> maxHist* </td>
    <td> int </td>
    <td> Maximum number of previous trial solutions (N_h) that 
         will be retained in memory for use by the AM algorithm .
         (Optional, 50 by default) 
    </td>
  </tr>
  <tr>
    <td> verbose* </td>
    <td> int </td>
    <td> Integer level 0, 1, 2 for verbosity of log output during 
         iteration, with 0 being most concise. (Optional, and 0 by 
         default) 
    </td>
  </tr>
  <tr>
    <td> errorType* </td>
    <td> string </td>
    <td> Identifer for the type of variable used to define scalar
         error . The only allowed values are "norm", "rms" "max", and 
         "relNorm", as discussed below. (Optional, equal to "relNorm" 
         by default) </td>
  </tr>
  <tr>
    <td> lambda* </td>
    <td> real </td>
    <td> Mixing parameter in the standard Anderson mixing correction
         step.  (Optional, 1.0 by default) </td>
  </tr>
  <tr>
    <td> useLambdaRamp* </td>
    <td> bool </td>
    <td> If true (1), use the ramp factor \f$ \alpha = 1 - r^{K+1} \f$ 
         while K < maxHist, \f$ \alpha = 1 \f$ thereafter. If false (0), 
         set \f$ \alpha = 1 \f$ for all iterations
         (Optional, true by default)  </td>
  </tr>
  <tr>
    <td> r* </td>
    <td> real </td>
    <td> Ratio r used to compute factor \f$ \alpha = 1 - r^{K+1} \f$ 
         while K < maxHist if the ramp factor is enabled.
         (Optional, 0.9 by default) </td>
  </tr>
</table>

Comments:

  - The error tolerance parameter "epsilon" is usually the only required 
    parameter, as indicated in the above table. 

  - The parameters lambda, useLambdaRamp, and r are only valid for 
    subclasses that use the standard "mixing" correction step, as
    described below. For such classes, the parameter r may appear only 
    if useLambaRamp is true. 

  - Default values given above are those defined in the AmIteratorTmpl
    class template. Some may be reset by subclasses. See subclass 
    documentation for reliable values.

  - Subclasses Rpc::AmCompressor and Rpg::AmCompressor, which use a 
    standard AM mixing algorithm to implement a compressor algorithm for
    PS-FTS, set useLambdaRamp false by default.

*/
}
